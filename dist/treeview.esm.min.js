function e(e, t, n) {
  return (
    (t = (function (e) {
      var t = (function (e, t) {
        if ("object" != typeof e || null === e) return e;
        var n = e[Symbol.toPrimitive];
        if (void 0 !== n) {
          var s = n.call(e, t || "default");
          if ("object" != typeof s) return s;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
      })(e, "string");
      return "symbol" == typeof t ? t : String(t);
    })(t)) in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = n),
    e
  );
}
function t(e, t) {
  try {
    if ("object" != typeof t) {
      throw new TypeError(
        `AccessibleMenu: Elements given to isValidInstance() must be inside of an object. ${typeof t} given.`
      );
    }
    for (const n in t)
      if (!(t[n] instanceof e)) {
        const s = typeof t[n];
        throw new TypeError(
          `AccessibleMenu: ${n} must be an instance of ${e.name}. ${s} given.`
        );
      }
    return !0;
  } catch (e) {
    return console.error(e), !1;
  }
}
function n(e, t) {
  try {
    if ("object" != typeof t) {
      throw new TypeError(
        `AccessibleMenu: Values given to isValidType() must be inside of an object. ${typeof t} given.`
      );
    }
    for (const n in t) {
      const s = typeof t[n];
      if (s !== e)
        throw new TypeError(`AccessibleMenu: ${n} must be a ${e}. ${s} given.`);
    }
    return !0;
  } catch (e) {
    return console.error(e), !1;
  }
}
function s(e) {
  try {
    if ("object" != typeof e) {
      throw new TypeError(
        `AccessibleMenu: Values given to isCSSSelector() must be inside of an object. ${typeof e} given.`
      );
    }
    for (const t in e)
      try {
        if (null === e[t]) throw new Error();
        document.querySelector(e[t]);
      } catch (n) {
        throw new TypeError(
          `AccessibleMenu: ${t} must be a valid CSS selector. "${e[t]}" given.`
        );
      }
    return !0;
  } catch (e) {
    return console.error(e), !1;
  }
}
function l(e) {
  try {
    if ("object" != typeof e || Array.isArray(e)) {
      throw new TypeError(
        `AccessibleMenu: Values given to isValidClassList() must be inside of an object. ${typeof e} given.`
      );
    }
    for (const t in e) {
      const n = typeof e[t];
      if ("string" !== n) {
        if (!Array.isArray(e[t]))
          throw new TypeError(
            `AccessibleMenu: ${t} must be a string or an array of strings. ${n} given.`
          );
        e[t].forEach((e) => {
          if ("string" != typeof e)
            throw new TypeError(
              `AccessibleMenu: ${t} must be a string or an array of strings. An array containing non-strings given.`
            );
        });
      } else {
        const n = {};
        (n[t] = e[t]), s(n);
      }
    }
    return !0;
  } catch (e) {
    return console.error(e), !1;
  }
}
function r(e) {
  try {
    if ("object" != typeof e) {
      throw new TypeError(
        `AccessibleMenu: Values given to isValidHoverType() must be inside of an object. ${typeof e} given.`
      );
    }
    const t = ["off", "on", "dynamic"];
    for (const n in e)
      if (!t.includes(e[n]))
        throw new TypeError(
          `AccessibleMenu: ${n} must be one of the following values: ${t.join(
            ", "
          )}. "${e[n]}" given.`
        );
    return !0;
  } catch (e) {
    return console.error(e), !1;
  }
}
class o {
  constructor(t) {
    let {
      menuToggleElement: n,
      parentElement: s,
      controlledMenu: l,
      parentMenu: r = null,
    } = t;
    e(this, "_dom", { toggle: null, parent: null }),
      e(this, "_elements", { controlledMenu: null, parentMenu: null }),
      e(this, "_open", !1),
      e(
        this,
        "_expandEvent",
        new CustomEvent("accessibleMenuExpand", {
          bubbles: !0,
          detail: { toggle: this },
        })
      ),
      e(
        this,
        "_collapseEvent",
        new CustomEvent("accessibleMenuCollapse", {
          bubbles: !0,
          detail: { toggle: this },
        })
      ),
      (this._dom.toggle = n),
      (this._dom.parent = s),
      (this._elements.controlledMenu = l),
      (this._elements.parentMenu = r);
  }
  initialize() {
    if (
      (this.dom.toggle.setAttribute("aria-haspopup", "true"),
      this.dom.toggle.setAttribute("aria-expanded", "false"),
      (function (e, s) {
        if (n("string", { tagName: e }) && t(HTMLElement, s)) {
          const t = e.toLowerCase();
          let n = !0;
          for (const e in s) s[e].tagName.toLowerCase() !== t && (n = !1);
          return n;
        }
        return !1;
      })("button", { toggle: this.dom.toggle }) ||
        this.dom.toggle.setAttribute("role", "button"),
      "" === this.dom.toggle.id ||
        "" === this.elements.controlledMenu.dom.menu.id)
    ) {
      const e = Math.random()
        .toString(36)
        .replace(/[^a-z]+/g, "")
        .substr(0, 10);
      let t = this.dom.toggle.innerText.replace(/[^a-zA-Z0-9\s]/g, ""),
        n = e;
      !t.replace(/\s/g, "").length &&
        this.dom.toggle.getAttribute("aria-label") &&
        (t = this.dom.toggle
          .getAttribute("aria-label")
          .replace(/[^a-zA-Z0-9\s]/g, "")),
        t.replace(/\s/g, "").length > 0 &&
          ((t = t.toLowerCase().replace(/\s+/g, "-")),
          t.startsWith("-") && (t = t.substring(1)),
          t.endsWith("-") && (t = t.slice(0, -1)),
          (n = `${t}-${n}`)),
        (this.dom.toggle.id = this.dom.toggle.id || `${n}-menu-button`),
        (this.elements.controlledMenu.dom.menu.id =
          this.elements.controlledMenu.dom.menu.id || `${n}-menu`);
    }
    this.elements.controlledMenu.dom.menu.setAttribute(
      "aria-labelledby",
      this.dom.toggle.id
    ),
      this.dom.toggle.setAttribute(
        "aria-controls",
        this.elements.controlledMenu.dom.menu.id
      ),
      this._collapse(!1);
  }
  get dom() {
    return this._dom;
  }
  get elements() {
    return this._elements;
  }
  get isOpen() {
    return this._open;
  }
  set isOpen(e) {
    n("boolean", { value: e }), (this._open = e);
  }
  _expand() {
    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    const { closeClass: t, openClass: n } = this.elements.controlledMenu;
    this.dom.toggle.setAttribute("aria-expanded", "true"),
      "" !== n &&
        ("string" == typeof n
          ? this.elements.controlledMenu.dom.menu.classList.add(n)
          : this.elements.controlledMenu.dom.menu.classList.add(...n)),
      "" !== t &&
        ("string" == typeof t
          ? this.elements.controlledMenu.dom.menu.classList.remove(t)
          : this.elements.controlledMenu.dom.menu.classList.remove(...t)),
      e && this.dom.toggle.dispatchEvent(this._expandEvent);
  }
  _collapse() {
    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    const { closeClass: t, openClass: n } = this.elements.controlledMenu;
    this.dom.toggle.setAttribute("aria-expanded", "false"),
      "" !== t &&
        ("string" == typeof t
          ? this.elements.controlledMenu.dom.menu.classList.add(t)
          : this.elements.controlledMenu.dom.menu.classList.add(...t)),
      "" !== n &&
        ("string" == typeof n
          ? this.elements.controlledMenu.dom.menu.classList.remove(n)
          : this.elements.controlledMenu.dom.menu.classList.remove(...n)),
      e && this.dom.toggle.dispatchEvent(this._collapseEvent);
  }
  open() {
    (this.elements.controlledMenu.focusState = "self"),
      this._expand(),
      (this.isOpen = !0);
  }
  preview() {
    this.elements.parentMenu && (this.elements.parentMenu.focusState = "self"),
      this._expand(),
      (this.isOpen = !0);
  }
  close() {
    this.isOpen &&
      ((this.elements.controlledMenu.currentChild = 0),
      this.elements.controlledMenu.blur(),
      this.elements.parentMenu &&
        (this.elements.parentMenu.focusState = "self"),
      this._collapse(),
      (this.isOpen = !1));
  }
  toggle() {
    this.isOpen ? this.close() : this.open();
  }
  closeSiblings() {
    this.elements.parentMenu &&
      this.elements.parentMenu.elements.submenuToggles.forEach((e) => {
        e !== this && e.close();
      });
  }
  closeChildren() {
    this.elements.controlledMenu.elements.submenuToggles.forEach((e) =>
      e.close()
    );
  }
}
class i {
  constructor(t) {
    let {
      menuItemElement: n,
      menuLinkElement: s,
      parentMenu: l,
      isSubmenuItem: r = !1,
      childMenu: o = null,
      toggle: i = null,
    } = t;
    e(this, "_dom", { item: null, link: null }),
      e(this, "_elements", { parentMenu: null, childMenu: null, toggle: null }),
      e(this, "_submenu", !1),
      (this._dom.item = n),
      (this._dom.link = s),
      (this._elements.parentMenu = l),
      (this._elements.childMenu = o),
      (this._elements.toggle = i),
      (this._submenu = r);
  }
  initialize() {}
  get dom() {
    return this._dom;
  }
  get elements() {
    return this._elements;
  }
  get isSubmenuItem() {
    return this._submenu;
  }
  focus() {
    this.elements.parentMenu.shouldFocus && this.dom.link.focus();
  }
  blur() {
    this.elements.parentMenu.shouldFocus && this.dom.link.blur();
  }
}
function u(e) {
  try {
    const t = e.key || e.keyCode,
      n = {
        Enter: "Enter" === t || 13 === t,
        Space: " " === t || "Spacebar" === t || 32 === t,
        Escape: "Escape" === t || "Esc" === t || 27 === t,
        ArrowUp: "ArrowUp" === t || "Up" === t || 38 === t,
        ArrowRight: "ArrowRight" === t || "Right" === t || 39 === t,
        ArrowDown: "ArrowDown" === t || "Down" === t || 40 === t,
        ArrowLeft: "ArrowLeft" === t || "Left" === t || 37 === t,
        Home: "Home" === t || 36 === t,
        End: "End" === t || 35 === t,
        Character: isNaN(t) && !!t.match(/^[a-zA-Z]{1}$/),
        Tab: "Tab" === t || 9 === t,
        Asterisk: "*" === t || 56 === t,
      };
    return Object.keys(n).find((e) => !0 === n[e]) || "";
  } catch (e) {
    return "";
  }
}
function h(e) {
  e.preventDefault(), e.stopPropagation();
}
class m {
  constructor(t) {
    let {
      menuElement: n,
      menuItemSelector: s = "li",
      menuLinkSelector: l = "a",
      submenuItemSelector: r = "",
      submenuToggleSelector: u = "a",
      submenuSelector: h = "ul",
      controllerElement: c = null,
      containerElement: a = null,
      openClass: d = "show",
      closeClass: p = "hide",
      isTopLevel: g = !0,
      parentMenu: f = null,
      hoverType: b = "off",
      hoverDelay: M = 250,
    } = t;
    e(this, "_MenuType", m),
      e(this, "_MenuItemType", i),
      e(this, "_MenuToggleType", o),
      e(this, "_dom", {
        menu: null,
        menuItems: [],
        submenuItems: [],
        submenuToggles: [],
        submenus: [],
        controller: null,
        container: null,
      }),
      e(this, "_selectors", {
        menuItems: "",
        menuLinks: "",
        submenuItems: "",
        submenuToggles: "",
        submenus: "",
      }),
      e(this, "_elements", {
        menuItems: [],
        submenuToggles: [],
        controller: null,
        parentMenu: null,
        rootMenu: null,
      }),
      e(this, "_openClass", "show"),
      e(this, "_closeClass", "hide"),
      e(this, "_root", !0),
      e(this, "_currentChild", 0),
      e(this, "_focusState", "none"),
      e(this, "_currentEvent", "none"),
      e(this, "_hoverType", "off"),
      e(this, "_hoverDelay", 250),
      (this._dom.menu = n),
      (this._dom.controller = c),
      (this._dom.container = a),
      (this._selectors.menuItems = s),
      (this._selectors.menuLinks = l),
      (this._selectors.submenuItems = r),
      (this._selectors.submenuToggles = u),
      (this._selectors.submenus = h),
      (this._elements.menuItems = []),
      (this._elements.submenuToggles = []),
      (this._elements.controller = null),
      (this._elements.parentMenu = f),
      (this._elements.rootMenu = g ? this : null),
      (this._openClass = d || ""),
      (this._closeClass = p || ""),
      (this._root = g),
      (this._hoverType = b),
      (this._hoverDelay = M);
  }
  initialize() {
    if (!this._validate())
      throw new Error(
        "AccesibleMenu: cannot initialize menu. See other error messages for more information."
      );
    if (
      (null === this.elements.rootMenu && this._findRootMenu(this),
      this._setDOMElements(),
      this.isTopLevel && this.dom.controller && this.dom.container)
    ) {
      const e = new this._MenuToggleType({
        menuToggleElement: this.dom.controller,
        parentElement: this.dom.container,
        controlledMenu: this,
      });
      this._elements.controller = e;
    }
    this._createChildElements();
  }
  get dom() {
    return this._dom;
  }
  get selectors() {
    return this._selectors;
  }
  get elements() {
    return this._elements;
  }
  get isTopLevel() {
    return this._root;
  }
  get openClass() {
    return this.isTopLevel ? this._openClass : this.elements.rootMenu.openClass;
  }
  get closeClass() {
    return this.isTopLevel
      ? this._closeClass
      : this.elements.rootMenu.closeClass;
  }
  get currentChild() {
    return this._currentChild;
  }
  get focusState() {
    return this._focusState;
  }
  get currentEvent() {
    return this._currentEvent;
  }
  get currentMenuItem() {
    return this.elements.menuItems[this.currentChild];
  }
  get hoverType() {
    return this._root ? this._hoverType : this.elements.rootMenu.hoverType;
  }
  get hoverDelay() {
    return this._root ? this._hoverDelay : this.elements.rootMenu.hoverDelay;
  }
  get shouldFocus() {
    let e = !1;
    return (
      ("keyboard" !== this.currentEvent && "character" !== this.currentEvent) ||
        (e = !0),
      "mouse" === this.currentEvent && "dynamic" === this.hoverType && (e = !0),
      e
    );
  }
  set openClass(e) {
    l({ openClass: e }), this._openClass !== e && (this._openClass = e);
  }
  set closeClass(e) {
    l({ closeClass: e }), this._closeClass !== e && (this._closeClass = e);
  }
  set currentChild(e) {
    function t(e) {
      if (
        ["mouse", "character"].includes(e.currentEvent) &&
        e.elements.parentMenu
      ) {
        let t = 0,
          n = !1;
        for (; !n && t < e.elements.parentMenu.elements.menuItems.length; ) {
          const s = e.elements.parentMenu.elements.menuItems[t];
          s.isSubmenuItem &&
            s.elements.toggle.elements.controlledMenu === e &&
            ((n = !0),
            (e.elements.parentMenu.currentEvent = e.currentEvent),
            (e.elements.parentMenu.currentChild = t)),
            t++;
        }
      }
    }
    n("number", { value: e }),
      e < -1
        ? ((this._currentChild = -1), t(this))
        : e >= this.elements.menuItems.length
        ? ((this._currentChild = this.elements.menuItems.length - 1), t(this))
        : this.focusChild !== e && ((this._currentChild = e), t(this));
  }
  set focusState(e) {
    !(function (e) {
      try {
        if ("object" != typeof e)
          throw new TypeError(
            `AccessibleMenu: Values given to isValidState() must be inside of an object. ${typeof e} given.`
          );
        const t = ["none", "self", "child"];
        for (const n in e)
          if (!t.includes(e[n]))
            throw new TypeError(
              `AccessibleMenu: ${n} must be one of the following values: ${t.join(
                ", "
              )}. "${e[n]}" given.`
            );
      } catch (e) {
        return console.error(e), !1;
      }
    })({ value: e }),
      this._focusState !== e && (this._focusState = e),
      this.elements.submenuToggles.length > 0 &&
        ("self" === e || "none" === e) &&
        this.elements.submenuToggles.forEach((e) => {
          e.elements.controlledMenu.focusState = "none";
        }),
      !this.elements.parentMenu ||
        ("self" !== e && "child" !== e) ||
        (this.elements.parentMenu.focusState = "child");
  }
  set currentEvent(e) {
    !(function (e) {
      try {
        if ("object" != typeof e)
          throw new TypeError(
            `AccessibleMenu: Values given to isValidEvent() must be inside of an object. ${typeof e} given.`
          );
        const t = ["none", "mouse", "keyboard", "character"];
        for (const n in e)
          if (!t.includes(e[n]))
            throw new TypeError(
              `AccessibleMenu: ${n} must be one of the following values: ${t.join(
                ", "
              )}. "${e[n]}" given.`
            );
      } catch (e) {
        return console.error(e), !1;
      }
    })({ value: e }),
      this._currentEvent !== e &&
        ((this._currentEvent = e),
        this.elements.submenuToggles.length > 0 &&
          this.elements.submenuToggles.forEach((t) => {
            t.elements.controlledMenu.currentEvent = e;
          }));
  }
  set hoverType(e) {
    r({ value: e }), this._hoverType !== e && (this._hoverType = e);
  }
  set hoverDelay(e) {
    n("number", { value: e }), this._hoverDelay !== e && (this._hoverDelay = e);
  }
  _validate() {
    let e = !0;
    return (
      null !== this._dom.container || null !== this._dom.controller
        ? t(HTMLElement, {
            menuElement: this._dom.menu,
            controllerElement: this._dom.controller,
            containerElement: this._dom.container,
          }) || (e = !1)
        : t(HTMLElement, { menuElement: this._dom.menu }) || (e = !1),
      "" !== this._selectors.submenuItems
        ? s({
            menuItemSelector: this._selectors.menuItems,
            menuLinkSelector: this._selectors.menuLinks,
            submenuItemSelector: this._selectors.submenuItems,
            submenuToggleSelector: this._selectors.submenuToggles,
            submenuSelector: this._selectors.submenus,
          }) || (e = !1)
        : s({
            menuItemSelector: this._selectors.menuItems,
            menuLinkSelector: this._selectors.menuLinks,
          }) || (e = !1),
      "" === this._openClass || l({ openClass: this._openClass }) || (e = !1),
      "" === this._closeClass ||
        l({ closeClass: this._closeClass }) ||
        (e = !1),
      n("boolean", { isTopLevel: this._root }) || (e = !1),
      null === this._elements.parentMenu ||
        t(m, { parentMenu: this._elements.parentMenu }) ||
        (e = !1),
      r({ hoverType: this._hoverType }) || (e = !1),
      n("number", { hoverDelay: this._hoverDelay }) || (e = !1),
      e
    );
  }
  _setDOMElementType(e) {
    let n =
        arguments.length > 1 && void 0 !== arguments[1]
          ? arguments[1]
          : this.dom.menu,
      s = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    if ("string" != typeof this.selectors[e])
      throw new Error(
        `AccessibleMenu: "${e}" is not a valid element type within the menu.`
      );
    {
      if (!Array.isArray(this.dom[e]))
        throw new Error(
          `AccessibleMenu: The "${e}" element cannot be set through _setDOMElementType.`
        );
      n !== this.dom.menu && t(HTMLElement, { base: n });
      const l = Array.from(n.querySelectorAll(this.selectors[e])).filter(
        (e) => e.parentElement === n
      );
      this._dom[e] = s ? l : [...this._dom[e], ...l];
    }
  }
  _resetDOMElementType(e) {
    if (void 0 === this.dom[e])
      throw new Error(
        `AccessibleMenu: "${e}" is not a valid element type within the menu.`
      );
    if (!Array.isArray(this.dom[e]))
      throw new Error(
        `AccessibleMenu: The "${e}" element cannot be reset through _resetDOMElementType.`
      );
    this._dom[e] = [];
  }
  _setDOMElements() {
    this._setDOMElementType("menuItems"),
      "" !== this.selectors.submenuItems &&
        (this._setDOMElementType("submenuItems"),
        this._resetDOMElementType("submenuToggles"),
        this._resetDOMElementType("submenus"),
        this.dom.submenuItems.forEach((e) => {
          this._setDOMElementType("submenuToggles", e, !1),
            this._setDOMElementType("submenus", e, !1);
        }));
  }
  _findRootMenu(e) {
    if (e.isTopLevel) this._elements.rootMenu = e;
    else {
      if (null === e.elements.parentMenu)
        throw new Error("Cannot find root menu.");
      this._findRootMenu(e.elements.parentMenu);
    }
  }
  _createChildElements() {
    this.dom.menuItems.forEach((e) => {
      let t;
      if (this.dom.submenuItems.includes(e)) {
        const n = e.querySelector(this.selectors.submenuToggles),
          s = e.querySelector(this.selectors.submenus),
          l = new this._MenuType({
            menuElement: s,
            menuItemSelector: this.selectors.menuItems,
            menuLinkSelector: this.selectors.menuLinks,
            submenuItemSelector: this.selectors.submenuItems,
            submenuToggleSelector: this.selectors.submenuToggles,
            submenuSelector: this.selectors.submenus,
            openClass: this.openClass,
            closeClass: this.closeClass,
            isTopLevel: !1,
            parentMenu: this,
            hoverType: this.hoverType,
            hoverDelay: this.hoverDelay,
          }),
          r = new this._MenuToggleType({
            menuToggleElement: n,
            parentElement: e,
            controlledMenu: l,
            parentMenu: this,
          });
        this._elements.submenuToggles.push(r),
          (t = new this._MenuItemType({
            menuItemElement: e,
            menuLinkElement: n,
            parentMenu: this,
            isSubmenuItem: !0,
            childMenu: l,
            toggle: r,
          }));
      } else {
        const n = e.querySelector(this.selectors.menuLinks);
        t = new this._MenuItemType({
          menuItemElement: e,
          menuLinkElement: n,
          parentMenu: this,
        });
      }
      this._elements.menuItems.push(t);
    });
  }
  _handleFocus() {
    this.elements.menuItems.forEach((e, t) => {
      e.dom.link.addEventListener("focus", () => {
        (this.focusState = "self"), (this.currentChild = t);
      });
    });
  }
  _handleClick() {
    function e(e, t, n) {
      h(n),
        t.toggle(),
        t.isOpen &&
          ((e.focusState = "self"),
          (t.elements.controlledMenu.focusState = "none"));
    }
    this.elements.menuItems.forEach((t, n) => {
      t.dom.link.addEventListener(
        "pointerdown",
        () => {
          (this.currentEvent = "mouse"),
            this.elements.rootMenu.blurChildren(),
            this.focusChild(n);
        },
        { passive: !0 }
      ),
        t.isSubmenuItem &&
          t.elements.toggle.dom.toggle.addEventListener("pointerup", (n) => {
            (this.currentEvent = "mouse"), e(this, t.elements.toggle, n);
          });
    }),
      this.isTopLevel &&
        this.elements.controller &&
        this.elements.controller.dom.toggle.addEventListener(
          "pointerup",
          (t) => {
            (this.currentEvent = "mouse"), e(this, this.elements.controller, t);
          }
        );
  }
  _handleHover() {
    this.elements.menuItems.forEach((e, t) => {
      e.dom.link.addEventListener("pointerenter", (n) => {
        if ("pen" !== n.pointerType && "touch" !== n.pointerType)
          if ("on" === this.hoverType)
            (this.currentEvent = "mouse"),
              (this.currentChild = t),
              e.isSubmenuItem && e.elements.toggle.preview();
          else if ("dynamic" === this.hoverType) {
            const n = this.elements.submenuToggles.some((e) => e.isOpen);
            (this.currentChild = t),
              (this.isTopLevel && "none" === this.focusState) ||
                ((this.currentEvent = "mouse"), this.focusCurrentChild()),
              !e.isSubmenuItem ||
                (this.isTopLevel && !n) ||
                ((this.currentEvent = "mouse"), e.elements.toggle.preview());
          }
      }),
        e.isSubmenuItem &&
          e.dom.item.addEventListener("pointerleave", (t) => {
            "pen" !== t.pointerType &&
              "touch" !== t.pointerType &&
              ("on" === this.hoverType
                ? this.hoverDelay > 0
                  ? setTimeout(() => {
                      (this.currentEvent = "mouse"), e.elements.toggle.close();
                    }, this.hoverDelay)
                  : ((this.currentEvent = "mouse"), e.elements.toggle.close())
                : "dynamic" === this.hoverType &&
                  (this.isTopLevel ||
                    (this.hoverDelay > 0
                      ? setTimeout(() => {
                          (this.currentEvent = "mouse"),
                            e.elements.toggle.close(),
                            this.focusCurrentChild();
                        }, this.hoverDelay)
                      : ((this.currentEvent = "mouse"),
                        e.elements.toggle.close(),
                        this.focusCurrentChild()))));
          });
    });
  }
  _handleKeydown() {
    this.isTopLevel &&
      this.elements.controller &&
      this.elements.controller.dom.toggle.addEventListener("keydown", (e) => {
        this.currentEvent = "keyboard";
        const t = u(e);
        ("Space" !== t && "Enter" !== t) || h(e);
      });
  }
  _handleKeyup() {
    this.isTopLevel &&
      this.elements.controller &&
      this.elements.controller.dom.toggle.addEventListener("keyup", (e) => {
        this.currentEvent = "keyboard";
        const t = u(e);
        ("Space" !== t && "Enter" !== t) ||
          (h(e), this.elements.controller.open(), this.focusFirstChild());
      });
  }
  focus() {
    (this.focusState = "self"), this.shouldFocus && this.dom.menu.focus();
  }
  blur() {
    (this.focusState = "none"), this.shouldFocus && this.dom.menu.blur();
  }
  focusCurrentChild() {
    (this.focusState = "self"),
      -1 !== this.currentChild && this.currentMenuItem.focus();
  }
  focusChild(e) {
    this.blurCurrentChild(), (this.currentChild = e), this.focusCurrentChild();
  }
  focusFirstChild() {
    this.focusChild(0);
  }
  focusLastChild() {
    this.focusChild(this.elements.menuItems.length - 1);
  }
  focusNextChild() {
    this.currentChild < this.elements.menuItems.length - 1
      ? this.focusChild(this.currentChild + 1)
      : this.focusCurrentChild();
  }
  focusPreviousChild() {
    this.currentChild > 0
      ? this.focusChild(this.currentChild - 1)
      : this.focusCurrentChild();
  }
  blurCurrentChild() {
    (this.focusState = "none"),
      -1 !== this.currentChild && this.currentMenuItem.blur();
  }
  focusController() {
    this.dom.controller &&
      (this.shouldFocus && this.dom.controller.focus(),
      (this.focusState = "none"));
  }
  focusContainer() {
    this.dom.container &&
      (this.shouldFocus && this.dom.container.focus(),
      (this.focusState = "none"));
  }
  closeChildren() {
    this.elements.submenuToggles.forEach((e) => e.close());
  }
  blurChildren() {
    this.elements.menuItems.forEach((e) => {
      e.blur(), e.isSubmenuItem && e.elements.childMenu.blurChildren();
    });
  }
}
class c extends i {
  constructor(e) {
    let {
      menuItemElement: t,
      menuLinkElement: n,
      parentMenu: s,
      isSubmenuItem: l = !1,
      childMenu: r = null,
      toggle: o = null,
      initialize: i = !0,
    } = e;
    super({
      menuItemElement: t,
      menuLinkElement: n,
      parentMenu: s,
      isSubmenuItem: l,
      childMenu: r,
      toggle: o,
    }),
      i && this.initialize();
  }
  initialize() {
    super.initialize(),
      this.dom.item.setAttribute("role", "none"),
      this.dom.link.setAttribute("role", "treeitem"),
      (this.dom.link.tabIndex = -1);
  }
  focus() {
    super.focus(), (this.dom.link.tabIndex = 0);
  }
  blur() {
    super.blur(), (this.dom.link.tabIndex = -1);
  }
}
class a extends o {
  constructor(e) {
    let {
      menuToggleElement: t,
      parentElement: n,
      controlledMenu: s,
      parentMenu: l = null,
      initialize: r = !0,
    } = e;
    super({
      menuToggleElement: t,
      parentElement: n,
      controlledMenu: s,
      parentMenu: l,
    }),
      r && this.initialize();
  }
}
class d extends m {
  constructor(t) {
    let {
      menuElement: n,
      menuItemSelector: s = "li",
      menuLinkSelector: l = "a",
      submenuItemSelector: r = "",
      submenuToggleSelector: o = "a",
      submenuSelector: i = "ul",
      controllerElement: u = null,
      containerElement: h = null,
      openClass: m = "show",
      closeClass: p = "hide",
      isTopLevel: g = !0,
      parentMenu: f = null,
      hoverType: b = "off",
      hoverDelay: M = 250,
      initialize: v = !0,
    } = t;
    super({
      menuElement: n,
      menuItemSelector: s,
      menuLinkSelector: l,
      submenuItemSelector: r,
      submenuToggleSelector: o,
      submenuSelector: i,
      controllerElement: u,
      containerElement: h,
      openClass: m,
      closeClass: p,
      isTopLevel: g,
      parentMenu: f,
      hoverType: b,
      hoverDelay: M,
    }),
      e(this, "_MenuType", d),
      e(this, "_MenuItemType", c),
      e(this, "_MenuToggleType", a),
      v && this.initialize();
  }
  initialize() {
    try {
      super.initialize(),
        this.isTopLevel
          ? (this.dom.menu.setAttribute("role", "tree"),
            (this.elements.menuItems[0].dom.link.tabIndex = 0))
          : this.dom.menu.setAttribute("role", "group"),
        this._handleFocus(),
        this._handleClick(),
        this._handleHover(),
        this._handleKeydown(),
        this._handleKeyup();
    } catch (e) {
      console.error(e);
    }
  }
  _handleKeydown() {
    super._handleKeydown(),
      this.dom.menu.addEventListener("keydown", (e) => {
        this.currentEvent = "keyboard";
        const t = u(e);
        if (
          ("Tab" === t &&
            ("none" !== this.elements.rootMenu.focusState
              ? this.elements.rootMenu.blur()
              : this.elements.rootMenu.focus()),
          "self" === this.focusState)
        ) {
          const n = ["Enter", "ArrowRight"],
            s = ["Escape"];
          ([
            "Space",
            "ArrowUp",
            "ArrowDown",
            "ArrowLeft",
            "Asterisk",
            "Home",
            "End",
          ].includes(t) ||
            (this.currentMenuItem.isSubmenuItem && n.includes(t)) ||
            (this.elements.controller && s.includes(t))) &&
            h(e);
        }
      });
  }
  _handleKeyup() {
    super._handleKeyup(),
      this.dom.menu.addEventListener("keyup", (e) => {
        this.currentEvent = "keyboard";
        const t = u(e),
          { altKey: n, crtlKey: s, metaKey: l } = e;
        if ("Character" !== t || n || s || l) {
          if ("self" === this.focusState)
            if ("Enter" === t || "Space" === t)
              h(e),
                this.currentMenuItem.isSubmenuItem
                  ? this.currentMenuItem.elements.toggle.isOpen
                    ? this.currentMenuItem.elements.toggle.close()
                    : this.currentMenuItem.elements.toggle.preview()
                  : this.currentMenuItem.dom.link.click();
            else if ("Escape" === t)
              this.isTopLevel &&
                this.elements.controller &&
                this.elements.controller.isOpen &&
                (this.elements.controller.close(), this.focusController());
            else if ("ArrowDown" === t)
              h(e),
                this.currentMenuItem.isSubmenuItem &&
                this.currentMenuItem.elements.toggle.isOpen
                  ? (this.blurCurrentChild(),
                    (this.currentMenuItem.elements.childMenu.currentEvent =
                      this.currentEvent),
                    this.currentMenuItem.elements.childMenu.focusFirstChild())
                  : this.isTopLevel ||
                    this.currentChild !== this.elements.menuItems.length - 1
                  ? this.focusNextChild()
                  : this.focusParentsNextChild();
            else if ("ArrowUp" === t) {
              h(e);
              const t = this.elements.menuItems[this.currentChild - 1];
              t && t.isSubmenuItem && t.elements.toggle.isOpen
                ? (this.blurCurrentChild(),
                  (this.currentChild = this.currentChild - 1),
                  (this.currentMenuItem.elements.childMenu.currentEvent =
                    this.currentEvent),
                  this.focusChildsLastNode())
                : this.isTopLevel || 0 !== this.currentChild
                ? this.focusPreviousChild()
                : (this.blurCurrentChild(),
                  (this.elements.parentMenu.currentEvent = this.currentEvent),
                  this.elements.parentMenu.focusCurrentChild());
            } else
              "ArrowRight" === t
                ? this.currentMenuItem.isSubmenuItem &&
                  (h(e),
                  this.currentMenuItem.elements.toggle.isOpen
                    ? (this.blurCurrentChild(),
                      (this.currentMenuItem.elements.childMenu.currentEvent =
                        this.currentEvent),
                      this.currentMenuItem.elements.childMenu.focusFirstChild())
                    : this.currentMenuItem.elements.toggle.preview())
                : "ArrowLeft" === t
                ? (h(e),
                  this.currentMenuItem.isSubmenuItem &&
                  this.currentMenuItem.elements.toggle.isOpen
                    ? (this.currentMenuItem.elements.childMenu.blurCurrentChild(),
                      this.currentMenuItem.elements.toggle.close())
                    : this.isTopLevel ||
                      (this.blurCurrentChild(),
                      (this.elements.parentMenu.currentEvent =
                        this.currentEvent),
                      this.elements.parentMenu.focusCurrentChild()))
                : "Home" === t
                ? (h(e),
                  this.blurCurrentChild(),
                  this.elements.rootMenu.focusFirstChild())
                : "End" === t
                ? (h(e),
                  this.blurCurrentChild(),
                  this.elements.rootMenu.focusLastNode())
                : "Asterisk" === t && (h(e), this.openChildren());
        } else
          h(e),
            (this.elements.rootMenu.currentEvent = "character"),
            this.focusNextNodeWithCharacter(e.key);
      });
  }
  focusLastNode() {
    const e = this.elements.menuItems.length - 1,
      t = this.elements.menuItems[e];
    t.isSubmenuItem && t.elements.toggle.isOpen
      ? ((this.currentChild = e),
        (t.elements.childMenu.currentEvent = this.currentEvent),
        t.elements.childMenu.focusLastNode())
      : this.focusLastChild();
  }
  openChildren() {
    this.elements.submenuToggles.forEach((e) => e.preview());
  }
  focusNextNodeWithCharacter(e) {
    const t = e.toLowerCase(),
      n = (function e(t) {
        let n = [];
        return (
          t.elements.menuItems.forEach((t) => {
            n.push(t),
              t.isSubmenuItem &&
                t.elements.toggle.isOpen &&
                (n = [...n, ...e(t.elements.toggle.elements.controlledMenu)]);
          }),
          n
        );
      })(this.elements.rootMenu),
      s = n.indexOf(this.currentMenuItem) + 1,
      l = [...n.slice(s), ...n.slice(0, s)];
    let r = 0,
      o = !1;
    for (; !o && r < l.length; ) {
      let e = "";
      if (
        ((e = l[r].dom.item.innerText
          ? l[r].dom.item.innerText
          : l[r].dom.item.textContent),
        (e = e.replace(/[\s]/g, "").toLowerCase().charAt(0)),
        e === t)
      ) {
        o = !0;
        const e = l[r].elements.parentMenu,
          t = e.elements.menuItems.indexOf(l[r]);
        this.elements.rootMenu.blurChildren(), e.focusChild(t);
      }
      r++;
    }
  }
  focusParentsNextChild() {
    this.elements.parentMenu &&
      ((this.elements.parentMenu.currentEvent = this.currentEvent),
      this.elements.parentMenu.currentChild ===
      this.elements.parentMenu.elements.menuItems.length - 1
        ? (this.elements.parentMenu.blurCurrentChild(),
          this.elements.parentMenu.focusParentsNextChild())
        : (this.blurChildren(), this.elements.parentMenu.focusNextChild()));
  }
  focusChildsLastNode() {
    (this.currentMenuItem.elements.childMenu.currentEvent = this.currentEvent),
      this.currentMenuItem.elements.childMenu.focusLastChild(),
      this.currentMenuItem.elements.childMenu.currentMenuItem.isSubmenuItem &&
        this.currentMenuItem.elements.childMenu.currentMenuItem.elements.toggle
          .isOpen &&
        (this.currentMenuItem.elements.childMenu.blurCurrentChild(),
        this.currentMenuItem.elements.childMenu.focusChildsLastNode());
  }
}
export { d as default };
//# sourceMappingURL=treeview.esm.min.js.map
