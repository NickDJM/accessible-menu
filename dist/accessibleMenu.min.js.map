{"version":3,"file":"accessibleMenu.min.js","sources":["../src/polyfills/array.from.polyfill.js","../src/validate.js","../src/polyfills/array.includes.polyfill.js","../src/polyfills/array.find.polyfill.js","../src/polyfills/string.startsWith.polyfill.js","../src/polyfills/string.endsWith.polyfill.js","../src/polyfills/customEvent.polyfill.js","../src/menuToggle.js","../src/eventHandlers.js","../src/menubar.js","../src/menuItem.js","../src/_baseMenu.js","../rollup.js","../src/disclosureMenu.js"],"sourcesContent":["// Production steps of ECMA-262, Edition 6, 22.1.2.1\nif (!Array.from) {\n  Array.from = (function () {\n    var toStr = Object.prototype.toString;\n    var isCallable = function (fn) {\n      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n    };\n    var toInteger = function (value) {\n      var number = Number(value);\n      if (isNaN(number)) { return 0; }\n      if (number === 0 || !isFinite(number)) { return number; }\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n    };\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n    var toLength = function (value) {\n      var len = toInteger(value);\n      return Math.min(Math.max(len, 0), maxSafeInteger);\n    };\n\n    // The length property of the from method is 1.\n    return function from(arrayLike/*, mapFn, thisArg */) {\n      // 1. Let C be the this value.\n      var C = this;\n\n      // 2. Let items be ToObject(arrayLike).\n      var items = Object(arrayLike);\n\n      // 3. ReturnIfAbrupt(items).\n      if (arrayLike == null) {\n        throw new TypeError('Array.from requires an array-like object - not null or undefined');\n      }\n\n      // 4. If mapfn is undefined, then let mapping be false.\n      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n      var T;\n      if (typeof mapFn !== 'undefined') {\n        // 5. else\n        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n        if (!isCallable(mapFn)) {\n          throw new TypeError('Array.from: when provided, the second argument must be a function');\n        }\n\n        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n        if (arguments.length > 2) {\n          T = arguments[2];\n        }\n      }\n\n      // 10. Let lenValue be Get(items, \"length\").\n      // 11. Let len be ToLength(lenValue).\n      var len = toLength(items.length);\n\n      // 13. If IsConstructor(C) is true, then\n      // 13. a. Let A be the result of calling the [[Construct]] internal method\n      // of C with an argument list containing the single item len.\n      // 14. a. Else, Let A be ArrayCreate(len).\n      var A = isCallable(C) ? Object(new C(len)) : new Array(len);\n\n      // 16. Let k be 0.\n      var k = 0;\n      // 17. Repeat, while k < lenâ€¦ (also steps a - h)\n      var kValue;\n      while (k < len) {\n        kValue = items[k];\n        if (mapFn) {\n          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n        } else {\n          A[k] = kValue;\n        }\n        k += 1;\n      }\n      // 18. Let putStatus be Put(A, \"length\", len, true).\n      A.length = len;\n      // 20. Return A.\n      return A;\n    };\n  }());\n}\n","import BaseMenu from \"./_baseMenu\";\nimport MenuToggle from \"./menuToggle\";\n\n/**\n * Checks to see if the provided element is an HTMLElement.\n *\n * If you provide the element to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|HTMLElement} element - The element to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isHTMLElement(element) {\n  let name = \"element\";\n\n  try {\n    if (!(element instanceof HTMLElement)) {\n      if (typeof element === \"object\") {\n        for (const key in element) {\n          name = key;\n\n          if (!(element[key] instanceof HTMLElement)) {\n            throw Error;\n          }\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be an HTML Element.`);\n  }\n}\n\n/**\n * Checks to see if the provided value is a valid CSS selector.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|string} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isCSSSelector(value) {\n  isString(value);\n\n  let name = \"value\";\n\n  try {\n    if (typeof value === \"object\") {\n      for (const key in value) {\n        name = key;\n\n        if (typeof value[key] !== \"string\") throw Error;\n\n        document.querySelector(value[key]);\n      }\n    } else {\n      document.querySelector(value);\n    }\n\n    return true;\n  } catch (error) {\n    throw new TypeError(`${name} must be a valid CSS selector.`);\n  }\n}\n\n/**\n * Checks to see if the provided value is a boolean.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|boolean} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isBoolean(value) {\n  let name = \"value\";\n\n  try {\n    if (typeof value !== \"boolean\") {\n      if (typeof value === \"object\") {\n        for (const key in value) {\n          name = key;\n\n          if (typeof value[key] !== \"boolean\") throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be a boolean.`);\n  }\n}\n\n/**\n * Checks to see if the provided value is a number.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|number} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isNumber(value) {\n  let name = \"value\";\n\n  try {\n    if (typeof value !== \"number\") {\n      if (typeof value === \"object\") {\n        for (const key in value) {\n          name = key;\n\n          if (typeof value[key] !== \"number\") throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be a number.`);\n  }\n}\n\n/**\n * Checks to see if the provided value is a string.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|string} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isString(value) {\n  let name = \"value\";\n\n  try {\n    if (typeof value !== \"string\") {\n      if (typeof value === \"object\") {\n        for (const key in value) {\n          name = key;\n\n          if (typeof value[key] !== \"string\") throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be a string.`);\n  }\n}\n\n/**\n * Checks to see if the provided event is an Event.\n *\n * If you provide the event to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|Event} event - The event to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isEvent(event) {\n  let name = \"event\";\n\n  try {\n    if (!(event instanceof Event)) {\n      if (typeof event === \"object\") {\n        for (const key in event) {\n          name = key;\n\n          if (!(event[key] instanceof Event)) throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be an Event.`);\n  }\n}\n\n/**\n * Checks to see if the provided event is a KeyboardEvent.\n *\n * If you provide the event to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|KeyboardEvent} event - The event to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isKeyboardEvent(event) {\n  let name = \"event\";\n\n  try {\n    if (!(event instanceof KeyboardEvent)) {\n      if (typeof event === \"object\") {\n        for (const key in event) {\n          name = key;\n\n          if (!(event[key] instanceof KeyboardEvent)) throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be a KeyboardEvent.`);\n  }\n}\n\n/**\n * Checks to see if the provided element is a menu.\n *\n * If you provide the element to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|BaseMenu} element - The element to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isMenu(element) {\n  let name = \"element\";\n\n  try {\n    if (!(element instanceof BaseMenu)) {\n      if (typeof element === \"object\") {\n        for (const key in element) {\n          name = key;\n\n          if (!(element[key] instanceof BaseMenu)) {\n            throw Error;\n          }\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(\n      `${name} must be an instance of either BaseMenu, Menubar, or DisclosureMenu`\n    );\n  }\n}\n\n/**\n * Checks to see if the provided element is using a specific tag.\n *\n * If you provide the element to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * @param   {string}             tagName - The name of the tag.\n * @param   {object|HTMLElement} element - The element to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isTag(tagName, element) {\n  isString(tagName);\n  isHTMLElement(element);\n\n  const tag = tagName.toLowerCase();\n\n  if (!(element instanceof HTMLElement)) {\n    let check = true;\n\n    for (const key in element) {\n      if (element[key].tagName.toLowerCase() !== tag) check = false;\n    }\n\n    return check;\n  } else {\n    return element.tagName.toLowerCase() === tag;\n  }\n}\n\n/**\n * Check to see if the provided element is a MenuToggle.\n *\n * If you provide the element to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|MenuToggle} element - The element to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isMenuToggle(element) {\n  let name = \"element\";\n\n  try {\n    if (!(element instanceof MenuToggle)) {\n      if (typeof element === \"object\" && !(element instanceof MenuToggle)) {\n        for (const key in element) {\n          name = key;\n\n          if (!(element[key] instanceof MenuToggle)) throw Error;\n        }\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(`${name} must be a MenuToggle.`);\n  }\n}\n\n/**\n * Check to see if the provided value is a valid focus state for a menu.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|string} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isValidState(value) {\n  isString(value);\n\n  const validStates = [\"none\", \"self\", \"child\"];\n  let name = \"value\";\n\n  try {\n    if (typeof value === \"object\") {\n      for (const key in value) {\n        name = key;\n\n        if (!validStates.includes(value[key])) {\n          throw Error;\n        }\n      }\n    } else if (!validStates.includes(value)) {\n      throw Error;\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new Error(\n      `${name} must be one of the following values: ${validStates.join(\", \")}`\n    );\n  }\n}\n\n/**\n * Check to see if the provided value is a valid event type for a menu.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|string} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isValidEvent(value) {\n  isString(value);\n\n  const validStates = [\"none\", \"mouse\", \"keyboard\"];\n  let name = \"value\";\n\n  try {\n    if (typeof value === \"object\") {\n      for (const key in value) {\n        name = key;\n\n        if (!validStates.includes(value[key])) {\n          throw Error;\n        }\n      }\n    } else if (!validStates.includes(value)) {\n      throw Error;\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new Error(\n      `${name} must be one of the following values: ${validStates.join(\", \")}`\n    );\n  }\n}\n\n/**\n * Checks to see if an event is supported by a node.\n *\n * @param   {string}      event   - The event type.\n * @param   {HTMLElement} element - The element to check.\n *\n * @returns {boolean} - The result.\n */\nexport function isEventSupported(event, element) {\n  isString(event);\n  isHTMLElement(element);\n\n  const eventProp = `on${event}`;\n\n  return typeof element[eventProp] !== \"undefined\";\n}\n\n/**\n * Checks to see if the provided value is either a string or an array of strings.\n *\n * If you provide the value to check inside of an object\n * the name of the variable will be output in the error message.\n *\n * Will return true is the check is successful.\n *\n * @param   {object|string|string[]} value - The value to check.\n *\n * @returns {boolean} - The result of the check.\n */\nexport function isValidClassList(value) {\n  let name = \"value\";\n\n  try {\n    if (typeof value !== \"string\") {\n      if (typeof value === \"object\") {\n        for (const key in value) {\n          name = key;\n\n          if (typeof value[key] !== \"string\") {\n            if (Array.isArray(value[key])) {\n              value[key].forEach((item) => {\n                isString(item);\n              });\n            } else {\n              throw Error;\n            }\n          }\n        }\n      } else if (Array.isArray(value)) {\n        isString(value);\n      } else {\n        throw Error;\n      }\n    } else {\n      return true;\n    }\n  } catch (error) {\n    throw new TypeError(\n      `${name} must be either a string or an array of strings.`\n    );\n  }\n}\n","if (!Array.includes) {\n  Array.prototype.includes = function(search) {\n    return !!~this.indexOf(search);\n  }\n}\n","// https://tc39.github.io/ecma262/#sec-array.prototype.find\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function(predicate) {\n      // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, Â« kValue, k, O Â»)).\n        // d. If testResult is true, return kValue.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return kValue;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return undefined.\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n","if (!String.prototype.startsWith) {\n  Object.defineProperty(String.prototype, 'startsWith', {\n    value: function (search, rawPos) {\n      var pos = rawPos > 0 ? rawPos | 0 : 0;\n      return this.substring(pos, pos + search.length) === search;\n    }\n  });\n}","if (!String.prototype.endsWith) {\n\tString.prototype.endsWith = function(search, this_len) {\n\t\tif (this_len === undefined || this_len > this.length) {\n\t\t\tthis_len = this.length;\n\t\t}\n\t\treturn this.substring(this_len - search.length, this_len) === search;\n\t};\n}","(function () {\n\n  if ( typeof window.CustomEvent === \"function\" ) return false;\n\n  function CustomEvent ( event, params ) {\n    params = params || { bubbles: false, cancelable: false, detail: null };\n    var evt = document.createEvent( 'CustomEvent' );\n    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n    return evt;\n   }\n\n  window.CustomEvent = CustomEvent;\n})();","import BaseMenu from \"./_baseMenu\";\nimport {\n  isHTMLElement,\n  isMenu,\n  isTag,\n  isBoolean,\n  isValidClassList,\n} from \"./validate\";\n\n/**\n * A link or button that controls the visibility of a menu.\n */\nclass MenuToggle {\n  /**\n   * {@inheritdoc}\n   *\n   * @param {object}               param0                       - The menu toggle object.\n   * @param {HTMLElement}          param0.menuToggleElement     - The toggle element in the DOM.\n   * @param {HTMLElement}          param0.parentElement         - The element containing the controlled menu.\n   * @param {BaseMenu}             param0.controlledMenu        - The menu controlled by this toggle.\n   * @param {string|string[]|null} [param0.openClass = \"show\"]  - The class to apply when the controlled menu is \"open\".\n   * @param {string|string[]|null} [param0.closeClass = \"hide\"] - The class to apply when the controlled menu is \"closed\".\n   * @param {BaseMenu|null}        [param0.parentMenu = null]   - The menu containing this toggle.\n   */\n  constructor({\n    menuToggleElement,\n    parentElement,\n    controlledMenu,\n    openClass = \"show\",\n    closeClass = \"hide\",\n    parentMenu = null,\n  }) {\n    // Run validations.\n    isHTMLElement({ menuToggleElement, parentElement });\n\n    if (parentMenu !== null) {\n      isMenu({ controlledMenu, parentMenu });\n    } else {\n      isMenu({ controlledMenu });\n    }\n\n    this.domElements = {\n      toggle: menuToggleElement,\n      parent: parentElement,\n    };\n    this.menuElements = {\n      controlledMenu,\n      parentMenu,\n    };\n    this.openClass = openClass || \"\";\n    this.closeClass = closeClass || \"\";\n    this.isOpen = false;\n\n    this.expandEvent = new CustomEvent(\"accessibleMenuExpand\", {\n      bubbles: true,\n      detail: { toggle: this },\n    });\n    this.collapseEvent = new CustomEvent(\"accessibleMenuCollapse\", {\n      bubbles: true,\n      detail: { toggle: this },\n    });\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize the toggle by ensuring WAI-ARIA values are set,\n   * handling click events, and adding new keydown events.\n   */\n  initialize() {\n    // Add WAI-ARIA properties.\n    this.dom.toggle.setAttribute(\"aria-haspopup\", \"true\");\n    this.dom.toggle.setAttribute(\"aria-expanded\", \"false\");\n\n    // If the toggle element is a button, there's no need to add a role.\n    if (!isTag(\"button\", this.dom.toggle)) {\n      this.dom.toggle.setAttribute(\"role\", \"button\");\n    }\n\n    // Ensure both toggle and menu have IDs.\n    if (\n      this.dom.toggle.id === \"\" ||\n      this.elements.controlledMenu.dom.menu.id === \"\"\n    ) {\n      const randomString = Math.random()\n        .toString(36)\n        .replace(/[^a-z]+/g, \"\")\n        .substr(0, 10);\n\n      let id = this.dom.toggle.innerText.replace(/[^a-zA-Z0-9\\s]/g, \"\");\n      let finalID = randomString;\n\n      if (\n        !id.replace(/\\s/g, \"\").length &&\n        this.dom.toggle.getAttribute(\"aria-label\")\n      ) {\n        id = this.dom.toggle\n          .getAttribute(\"aria-label\")\n          .replace(/[^a-zA-Z0-9\\s]/g, \"\");\n      }\n\n      if (id.replace(/\\s/g, \"\").length > 0) {\n        id = id.toLowerCase().replace(/\\s+/g, \"-\");\n\n        if (id.startsWith(\"-\")) {\n          id = id.substring(1);\n        }\n\n        if (id.endsWith(\"-\")) {\n          id = id.slice(0, -1);\n        }\n\n        finalID = `${id}-${finalID}`;\n      }\n\n      this.dom.toggle.id = this.dom.toggle.id || `${finalID}-menu-button`;\n      this.elements.controlledMenu.dom.menu.id =\n        this.elements.controlledMenu.dom.menu.id || `${finalID}-menu`;\n    }\n\n    // Set up proper aria label and control.\n    this.elements.controlledMenu.dom.menu.setAttribute(\n      \"aria-labelledby\",\n      this.dom.toggle.id\n    );\n    this.dom.toggle.setAttribute(\n      \"aria-controls\",\n      this.elements.controlledMenu.dom.menu.id\n    );\n\n    // Add closed class.\n    if (this.closeClass !== \"\") {\n      if (typeof this.closeClass === \"string\") {\n        this.elements.controlledMenu.dom.menu.classList.add(this.closeClass);\n      } else if (Array.isArray(this.closeClass)) {\n        this.closeClass.forEach((value) => {\n          this.elements.controlledMenu.dom.menu.classList.add(value);\n        });\n      }\n    }\n  }\n\n  /**\n   * The DOM elements within the toggle.\n   *\n   * @returns {object} - The DOM elements.\n   */\n  get dom() {\n    return this.domElements;\n  }\n\n  /**\n   * The elements within the toggle.\n   *\n   * @returns {object} - The elements.\n   */\n  get elements() {\n    return this.menuElements;\n  }\n\n  /**\n   * The open state on the menu.\n   *\n   * @returns {boolean} - The open state.\n   */\n  get isOpen() {\n    return this.show;\n  }\n\n  /**\n   * The class to apply when the controlled menu is \"open\".\n   *\n   * @returns {string} - The class.\n   */\n  get openClass() {\n    return this.controlledMenuOpenClass;\n  }\n\n  /**\n   * The class to apply when the controlled menu is \"closed\".\n   *\n   * @returns {string} - The class.\n   */\n  get closeClass() {\n    return this.controlledMenuCloseClass;\n  }\n\n  /**\n   * Set the open state on the menu.\n   *\n   * @param {boolean} value - The open state.\n   */\n  set isOpen(value) {\n    isBoolean({ value });\n\n    this.show = value;\n  }\n\n  /**\n   * Set the class to apply when the controlled menu is \"open\".\n   *\n   * @param {string} value - The class.\n   */\n  set openClass(value) {\n    isValidClassList({ openClass: value });\n\n    this.controlledMenuOpenClass = value;\n  }\n\n  /**\n   * Set the class to apply when the controlled menu is \"closed\".\n   *\n   * @param {string} value - The class.\n   */\n  set closeClass(value) {\n    isValidClassList({ closeClass: value });\n\n    this.controlledMenuCloseClass = value;\n  }\n\n  /**\n   * Expands the controlled menu.\n   *\n   * Alters ARIA attributes and classes.\n   */\n  expand() {\n    this.dom.toggle.setAttribute(\"aria-expanded\", \"true\");\n\n    // Add the open class\n    if (this.openClass !== \"\") {\n      if (typeof this.openClass === \"string\") {\n        this.elements.controlledMenu.dom.menu.classList.add(this.openClass);\n      } else if (Array.isArray(this.openClass)) {\n        this.openClass.forEach((value) => {\n          this.elements.controlledMenu.dom.menu.classList.add(value);\n        });\n      }\n    }\n\n    // Remove the close class.\n    if (this.closeClass !== \"\") {\n      if (typeof this.closeClass === \"string\") {\n        this.elements.controlledMenu.dom.menu.classList.remove(this.closeClass);\n      } else if (Array.isArray(this.closeClass)) {\n        this.closeClass.forEach((value) => {\n          this.elements.controlledMenu.dom.menu.classList.remove(value);\n        });\n      }\n    }\n\n    this.dom.toggle.dispatchEvent(this.expandEvent);\n  }\n\n  /**\n   * Collapses the controlled menu.\n   *\n   * Alters ARIA attributes and classes.\n   */\n  collapse() {\n    this.dom.toggle.setAttribute(\"aria-expanded\", \"false\");\n\n    // Add the close class\n    if (this.closeClass !== \"\") {\n      if (typeof this.closeClass === \"string\") {\n        this.elements.controlledMenu.dom.menu.classList.add(this.closeClass);\n      } else if (Array.isArray(this.closeClass)) {\n        this.closeClass.forEach((value) => {\n          this.elements.controlledMenu.dom.menu.classList.add(value);\n        });\n      }\n    }\n\n    // Remove the open class.\n    if (this.openClass !== \"\") {\n      if (typeof this.openClass === \"string\") {\n        this.elements.controlledMenu.dom.menu.classList.remove(this.openClass);\n      } else if (Array.isArray(this.openClass)) {\n        this.openClass.forEach((value) => {\n          this.elements.controlledMenu.dom.menu.classList.remove(value);\n        });\n      }\n    }\n\n    this.dom.toggle.dispatchEvent(this.collapseEvent);\n  }\n\n  /**\n   * Opens the controlled menu.\n   */\n  open() {\n    this.isOpen = true;\n\n    // Expand the controlled menu and close all siblings.\n    this.expand();\n    this.closeSiblings();\n\n    // Set proper focus states to parent & child.\n    if (this.elements.parentMenu) this.elements.parentMenu.focusState = \"child\";\n    this.elements.controlledMenu.focusState = \"self\";\n  }\n\n  /**\n   * Opens the controlled menu without the current focus entering it.\n   */\n  preview() {\n    this.isOpen = true;\n\n    // Expand the controlled menu and close all siblings.\n    this.expand();\n    this.closeSiblings();\n\n    // Set proper focus states to parent & child.\n    if (this.elements.parentMenu) {\n      this.elements.parentMenu.focusState = \"self\";\n    }\n\n    this.elements.controlledMenu.focusState = \"none\";\n  }\n\n  /**\n   * Closes the controlled menu.\n   */\n  close() {\n    if (this.isOpen) {\n      this.isOpen = false;\n\n      // Close the controlled menu and close all siblings.\n      this.collapse();\n      this.closeChildren();\n\n      // Set proper focus states to parent & child.\n      this.elements.controlledMenu.currentChild = 0;\n      this.elements.controlledMenu.blur();\n\n      if (this.elements.parentMenu) {\n        this.elements.parentMenu.focusState = \"self\";\n      }\n    }\n  }\n\n  /**\n   * Toggles the open state of the controlled menu.\n   */\n  toggle() {\n    if (this.isOpen) {\n      this.close();\n    } else {\n      this.open();\n    }\n  }\n\n  /**\n   * Closes all sibling menus.\n   */\n  closeSiblings() {\n    if (this.elements.parentMenu) {\n      this.elements.parentMenu.elements.submenuToggles.forEach((toggle) => {\n        if (toggle !== this) toggle.close();\n      });\n    }\n  }\n\n  /**\n   * Closes all child menus.\n   */\n  closeChildren() {\n    this.elements.controlledMenu.elements.submenuToggles.forEach((toggle) =>\n      toggle.close()\n    );\n  }\n}\n\nexport default MenuToggle;\n","import { isEvent, isKeyboardEvent } from \"./validate\";\n\n/**\n * Retrieves the pressed key from an event.\n *\n * @param   {KeyboardEvent} event - The keyboard event.\n *\n * @returns {string} - The name of the key.\n */\nexport function keyPress(event) {\n  // Run validation.\n  isKeyboardEvent(event);\n\n  try {\n    // Use event.key or event.keyCode to support older browsers.\n    const key = event.key || event.keyCode;\n    const keys = {\n      Enter: key === \"Enter\" || key === 13,\n      Space: key === \" \" || key === \"Spacebar\" || key === 32,\n      Escape: key === \"Escape\" || key === \"Esc\" || key === 27,\n      ArrowUp: key === \"ArrowUp\" || key === \"Up\" || key === 38,\n      ArrowRight: key === \"ArrowRight\" || key === \"Right\" || key === 39,\n      ArrowDown: key === \"ArrowDown\" || key === \"Down\" || key === 40,\n      ArrowLeft: key === \"ArrowLeft\" || key === \"Left\" || key === 37,\n      Home: key === \"Home\" || key === 36,\n      End: key === \"End\" || key === 35,\n      Character: !!key.match(/^[a-zA-Z]{1}$/),\n      Tab: key === \"Tab\" || key === 9,\n    };\n\n    return Object.keys(keys).find((key) => keys[key] === true);\n  } catch (error) {\n    // Return an empty string if something goes wrong.\n    return \"\";\n  }\n}\n\n/**\n * Stops an event from taking action.\n *\n * @param {Event} event - The event.\n */\nexport function preventEvent(event) {\n  // Run validation.\n  isEvent(event);\n\n  event.preventDefault();\n  event.stopPropagation();\n}\n","import BaseMenu from \"./_baseMenu\";\nimport { keyPress, preventEvent } from \"./eventHandlers\";\n\n/**\n * An accessible menubar navigation in the DOM.\n *\n * See https://www.w3.org/TR/wai-aria-practices-1.2/examples/menubar/menubar-1/menubar-1.html\n */\nclass Menubar extends BaseMenu {\n  /**\n   * {@inheritdoc}\n   *\n   * @param {object}           param0                               - The menu object.\n   * @param {HTMLElement}      param0.menuElement                   - The menu element in the DOM.\n   * @param {string}           [param0.menuItemSelector = \"li\"]     - The CSS selector string for menu items.\n   * @param {string}           [param0.menuLinkSelector = \"a\"]      - The CSS selector string for menu links.\n   * @param {string}           [param0.submenuItemSelector = \"\"]    - The CSS selector string for menu items containing submenus.\n   * @param {string}           [param0.submenuToggleSelector = \"a\"] - The CSS selector string for submenu toggle buttons/links.\n   * @param {string}           [param0.submenuSelector = \"ul\"]      - The CSS selector string for submenus.\n   * @param {HTMLElement|null} [param0.controllerElement = null]    - The element controlling the menu in the DOM.\n   * @param {HTMLElement|null} [param0.containerElement = null]     - The element containing the menu in the DOM.\n   * @param {string}           [param0.openClass = \"show\"]          - The class to apply when a menu is \"open\".\n   * @param {string}           [param0.closeClass = \"hide\"]         - The class to apply when a menu is \"closed\".\n   * @param {boolean}          [param0.isTopLevel = false]          - A flag to mark the root menu.\n   * @param {Menubar|null}     [param0.parentMenu = null]           - The parent menu to this menu.\n   * @param {boolean}          [param0.isHoverable = false]         - A flag to allow hover events on the menu.\n   * @param {number}           [param0.hoverDelay = 250]            - The delay for closing menus if the menu is hoverable (in miliseconds).\n   */\n  constructor({\n    menuElement,\n    menuItemSelector = \"li\",\n    menuLinkSelector = \"a\",\n    submenuItemSelector = \"\",\n    submenuToggleSelector = \"a\",\n    submenuSelector = \"ul\",\n    controllerElement = null,\n    containerElement = null,\n    openClass = \"show\",\n    closeClass = \"hide\",\n    isTopLevel = true,\n    parentMenu = null,\n    isHoverable = false,\n    hoverDelay = 250,\n  }) {\n    super({\n      menuElement,\n      menuItemSelector,\n      menuLinkSelector,\n      submenuItemSelector,\n      submenuToggleSelector,\n      submenuSelector,\n      controllerElement,\n      containerElement,\n      openClass,\n      closeClass,\n      isTopLevel,\n      parentMenu,\n      isHoverable,\n      hoverDelay,\n    });\n  }\n\n  /**\n   * Initializes the menu.\n   *\n   * This will also initialize all menu items and sub menus.\n   */\n  initialize() {\n    super.initialize();\n\n    this.dom.menu.setAttribute(\"role\", \"menubar\");\n\n    this.createChildElements(Menubar);\n    this.handleFocus();\n    this.handleClick();\n    if (this.isHoverable) this.handleHover();\n    this.handleKeydown();\n    this.handleKeyup();\n\n    this.elements.menuItems[0].dom.link.tabIndex = 0;\n  }\n\n  /**\n   * Handles keydown events throughout the menu for proper menu use.\n   */\n  handleKeydown() {\n    super.handleKeydown();\n\n    this.dom.menu.addEventListener(\"keydown\", (event) => {\n      this.currentEvent = \"keyboard\";\n\n      const key = keyPress(event);\n\n      if (key === \"Tab\") {\n        // Hitting Tab:\n        // - Moves focus out of the menu.\n        if (this.elements.rootMenu.focusState !== \"none\") {\n          this.elements.rootMenu.blur();\n          this.elements.rootMenu.closeChildren();\n        } else {\n          this.elements.rootMenu.focus();\n        }\n      }\n\n      // Prevent default event actions if we're handling the keyup event.\n      if (key === \"Character\") {\n        preventEvent(event);\n      } else if (this.isTopLevel) {\n        if (this.focusState === \"self\") {\n          const keys = [\"ArrowRight\", \"ArrowLeft\", \"Home\", \"End\"];\n          const submenuKeys = [\"Space\", \"Enter\", \"ArrowDown\", \"ArrowUp\"];\n          const controllerKeys = [\"Escape\"];\n\n          if (keys.includes(key)) {\n            preventEvent(event);\n          } else if (\n            this.currentMenuItem.isSubmenuItem &&\n            submenuKeys.includes(key)\n          ) {\n            preventEvent(event);\n          } else if (this.elements.controller && controllerKeys.includes(key)) {\n            preventEvent(event);\n          }\n        }\n      } else {\n        const keys = [\n          \"Escape\",\n          \"ArrowRight\",\n          \"ArrowLeft\",\n          \"ArrowDown\",\n          \"ArrowUp\",\n          \"Home\",\n          \"End\",\n        ];\n        const submenuKeys = [\"Space\", \"Enter\"];\n\n        if (keys.includes(key)) {\n          preventEvent(event);\n        } else if (\n          this.currentMenuItem.isSubmenuItem &&\n          submenuKeys.includes(key)\n        ) {\n          preventEvent(event);\n        }\n      }\n    });\n  }\n\n  /**\n   * Handles keyup events throughout the menu for proper menu use.\n   */\n  handleKeyup() {\n    super.handleKeyup();\n\n    this.dom.menu.addEventListener(\"keyup\", (event) => {\n      this.currentEvent = \"keyboard\";\n\n      const key = keyPress(event);\n      const { altKey, crtlKey, metaKey } = event;\n      const modifier = altKey || crtlKey || metaKey;\n\n      if (key === \"Character\" && !modifier) {\n        // Hitting Character:\n        // - Moves focus to next item in the menubar having a name that starts with the typed character.\n        // - If none of the items have a name starting with the typed character, focus does not move.\n        preventEvent(event);\n        this.focusNextChildWithCharacter(event.key);\n      } else if (this.isTopLevel) {\n        if (this.focusState === \"self\") {\n          if (key === \"Space\" || key === \"Enter\") {\n            // Hitting Space or Enter:\n            // - Opens submenu and moves focus to first item in the submenu.\n            if (this.currentMenuItem.isSubmenuItem) {\n              preventEvent(event);\n              this.currentMenuItem.elements.toggle.open();\n              // This ensures the the menu is _visually_ open before the child is focussed.\n              requestAnimationFrame(() => {\n                this.currentMenuItem.elements.childMenu.focusFirstChild();\n              });\n            }\n          } else if (key === \"ArrowRight\") {\n            // Hitting the Right Arrow:\n            // - Moves focus to the next item in the menubar.\n            // - If focus is on the last item, moves focus to the first item.\n            // - If focus was on an open submenu and the newly focussed item has a submenu, open the submenu.\n            preventEvent(event);\n\n            // Store the current item's info if its an open dropdown.\n            const previousChildOpen =\n              this.currentMenuItem.isSubmenuItem &&\n              this.currentMenuItem.elements.toggle.isOpen;\n\n            this.focusNextChild();\n\n            // Open the newly focussed submenu if applicable.\n            if (previousChildOpen) {\n              if (this.currentMenuItem.isSubmenuItem) {\n                this.currentMenuItem.elements.toggle.preview();\n              } else {\n                this.closeChildren();\n              }\n            }\n          } else if (key === \"ArrowLeft\") {\n            // Hitting the Left Arrow:\n            // - Moves focus to the previous item in the menubar.\n            // - If focus is on the first item, moves focus to the last item.\n            // - If focus was on an open submenu and the newly focussed item has a submenu, open the submenu.\n            preventEvent(event);\n\n            // Store the current item's info if its an open dropdown.\n            const previousChildOpen =\n              this.currentMenuItem.isSubmenuItem &&\n              this.currentMenuItem.elements.toggle.isOpen;\n\n            this.focusPreviousChild();\n\n            // Open the newly focussed submenu if applicable.\n            if (previousChildOpen) {\n              if (this.currentMenuItem.isSubmenuItem) {\n                this.currentMenuItem.elements.toggle.preview();\n              } else {\n                this.closeChildren();\n              }\n            }\n          } else if (key === \"ArrowDown\") {\n            // Hitting the Down Arrow:\n            // - Opens submenu and moves focus to first item in the submenu.\n            if (this.currentMenuItem.isSubmenuItem) {\n              preventEvent(event);\n              this.currentMenuItem.elements.toggle.open();\n              // This ensures the the menu is _visually_ open before the child is focussed.\n              requestAnimationFrame(() => {\n                this.currentMenuItem.elements.childMenu.focusFirstChild();\n              });\n            }\n          } else if (key === \"ArrowUp\") {\n            // Hitting the Up Arrow:\n            // - Opens submenu and moves focus to last item in the submenu.\n            if (this.currentMenuItem.isSubmenuItem) {\n              preventEvent(event);\n              this.currentMenuItem.elements.toggle.open();\n              // This ensures the the menu is _visually_ open before the child is focussed.\n              requestAnimationFrame(() => {\n                this.currentMenuItem.elements.childMenu.focusLastChild();\n              });\n            }\n          } else if (key === \"Home\") {\n            // Hitting Home:\n            // - Moves focus to first item in the menubar.\n            preventEvent(event);\n            this.focusFirstChild();\n          } else if (key === \"End\") {\n            // Hitting End:\n            // - Moves focus to last item in the menubar.\n            preventEvent(event);\n            this.focusLastChild();\n          } else if (key === \"Escape\") {\n            // Hitting Escape:\n            // - Closes menu.\n            const hasOpenChild = this.elements.submenuToggles.some(\n              (toggle) => toggle.isOpen\n            );\n\n            if (hasOpenChild) {\n              preventEvent(event);\n              this.closeChildren();\n            } else if (\n              this.isTopLevel &&\n              this.elements.controller &&\n              this.elements.controller.isOpen\n            ) {\n              preventEvent(event);\n              this.elements.controller.close();\n              this.focusController();\n            }\n          }\n        }\n      } else {\n        if (key === \"Space\" || key === \"Enter\") {\n          // Hitting Space or Enter:\n          // - Activates menu item, causing the link to be activated.\n          if (this.currentMenuItem.isSubmenuItem) {\n            preventEvent(event);\n            this.currentMenuItem.elements.toggle.open();\n            // This ensures the the menu is _visually_ open before the child is focussed.\n            requestAnimationFrame(() => {\n              this.currentMenuItem.elements.childMenu.focusFirstChild();\n            });\n          }\n        } else if (key === \"Escape\") {\n          // Hitting Escape:\n          // - Closes submenu.\n          // - Moves focus to parent menubar item.\n          preventEvent(event);\n          this.elements.rootMenu.closeChildren();\n          this.elements.rootMenu.focusCurrentChild();\n        } else if (key === \"ArrowRight\") {\n          // Hitting the Right Arrow:\n          // - If focus is on an item with a submenu, opens the submenu and places focus on the first item.\n          // - If focus is on an item that does not have a submenu:\n          //   - Closes submenu.\n          //   - Moves focus to next item in the menubar.\n          //   - Opens submenu of newly focused menubar item, keeping focus on that parent menubar item.\n          if (this.currentMenuItem.isSubmenuItem) {\n            preventEvent(event);\n            this.currentMenuItem.elements.toggle.open();\n            // This ensures the the menu is _visually_ open before the child is focussed.\n            requestAnimationFrame(() => {\n              this.currentMenuItem.elements.childMenu.focusFirstChild();\n            });\n          } else {\n            preventEvent(event);\n            this.elements.rootMenu.closeChildren();\n            this.elements.rootMenu.focusNextChild();\n\n            if (this.elements.rootMenu.currentMenuItem.isSubmenuItem) {\n              this.elements.rootMenu.currentMenuItem.elements.toggle.preview();\n            }\n          }\n        } else if (key === \"ArrowLeft\") {\n          // Hitting the Left Arrow:\n          // - Closes submenu and moves focus to parent menu item.\n          // - If parent menu item is in the menubar, also:\n          //   - moves focus to previous item in the menubar.\n          //   - Opens submenu of newly focused menubar item, keeping focus on that parent menubar item.\n          if (this.elements.parentMenu.currentMenuItem.isSubmenuItem) {\n            preventEvent(event);\n            this.elements.parentMenu.currentMenuItem.elements.toggle.close();\n            this.elements.parentMenu.focusCurrentChild();\n\n            if (this.elements.parentMenu === this.elements.rootMenu) {\n              this.elements.rootMenu.closeChildren();\n              this.elements.rootMenu.focusPreviousChild();\n\n              if (this.elements.rootMenu.currentMenuItem.isSubmenuItem) {\n                this.elements.rootMenu.currentMenuItem.elements.toggle.preview();\n              }\n            }\n          }\n        } else if (key === \"ArrowDown\") {\n          // Hitting the Down Arrow:\n          // - Moves focus to the next item in the menubar.\n          // - If focus is on the last item, moves focus to the first item.\n          preventEvent(event);\n          this.focusNextChild();\n        } else if (key === \"ArrowUp\") {\n          // Hitting the Up Arrow:\n          // - Moves focus to the previous item in the menubar.\n          // - If focus is on the first item, moves focus to the last item.\n          preventEvent(event);\n          this.focusPreviousChild();\n        } else if (key === \"Home\") {\n          // Hitting Home:\n          // - Moves focus to first item in the menubar.\n          preventEvent(event);\n          this.focusFirstChild();\n        } else if (key === \"End\") {\n          // Hitting End:\n          // - Moves focus to last item in the menubar.\n          preventEvent(event);\n          this.focusLastChild();\n        }\n      }\n    });\n  }\n}\n\nexport default Menubar;\n","import BaseMenu from \"./_baseMenu\";\nimport Menubar from \"./menubar\";\nimport MenuToggle from \"./menuToggle\";\nimport { isHTMLElement, isBoolean, isMenu, isMenuToggle } from \"./validate\";\n\n/**\n * A basic navigation link contained inside of a Menu.\n */\nclass MenuItem {\n  /**\n   * {@inheritdoc}\n   *\n   * @param {object}          param0                         - The menu item object.\n   * @param {HTMLElement}     param0.menuItemElement         - The menu item in the DOM.\n   * @param {HTMLElement}     param0.menuLinkElement         - The menu item's link in the DOM.\n   * @param {BaseMenu}        param0.parentMenu              - The parent menu.\n   * @param {boolean}         [param0.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.\n   * @param {BaseMenu|null}   [param0.childMenu = null]      - The child menu.\n   * @param {MenuToggle|null} [param0.toggle = null]         - The controller for the child menu.\n   */\n  constructor({\n    menuItemElement,\n    menuLinkElement,\n    parentMenu,\n    isSubmenuItem = false,\n    childMenu = null,\n    toggle = null,\n  }) {\n    // Run validations.\n    isHTMLElement({ menuItemElement, menuLinkElement });\n    isBoolean({ isSubmenuItem });\n\n    if (childMenu !== null) {\n      isMenu({ parentMenu, childMenu });\n    } else {\n      isMenu({ parentMenu });\n    }\n\n    if (toggle !== null) isMenuToggle({ toggle });\n\n    this.domElements = {\n      item: menuItemElement,\n      link: menuLinkElement,\n    };\n    this.menuElements = {\n      parentMenu,\n      childMenu,\n      toggle,\n    };\n    this.isController = isSubmenuItem;\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize the menu item by setting its tab index.\n   */\n  initialize() {\n    this.isMenubar = this.elements.parentMenu instanceof Menubar;\n\n    if (this.isMenubar) {\n      this.dom.item.setAttribute(\"role\", \"none\");\n      this.dom.link.setAttribute(\"role\", \"menuitem\");\n      this.dom.link.tabIndex = -1;\n    }\n  }\n\n  /**\n   * The DOM elements within the menu item.\n   *\n   * @returns {object} - The DOM elements.\n   */\n  get dom() {\n    return this.domElements;\n  }\n\n  /**\n   * The elements within the menu item.\n   *\n   * @returns {object} - The elements.\n   */\n  get elements() {\n    return this.menuElements;\n  }\n\n  /**\n   * A flag marking a submenu item.\n   *\n   * @returns {boolean} - The submenu flag.\n   */\n  get isSubmenuItem() {\n    return this.isController;\n  }\n\n  /**\n   * Focuses the menu item's link and set proper tabIndex.\n   */\n  focus() {\n    if (this.elements.parentMenu.currentEvent !== \"mouse\") {\n      this.dom.link.focus();\n    }\n\n    if (this.isMenubar && this.elements.parentMenu.isTopLevel) {\n      this.dom.link.tabIndex = 0;\n    }\n  }\n\n  /**\n   * Blurs the menu item's link and set proper tabIndex.\n   */\n  blur() {\n    if (this.elements.parentMenu.currentEvent !== \"mouse\") {\n      this.dom.link.blur();\n    }\n\n    if (this.isMenubar && this.elements.parentMenu.isTopLevel) {\n      this.dom.link.tabIndex = -1;\n    }\n  }\n}\n\nexport default MenuItem;\n","import MenuToggle from \"./menuToggle\";\nimport MenuItem from \"./menuItem\";\nimport {\n  isHTMLElement,\n  isCSSSelector,\n  isBoolean,\n  isMenu,\n  isNumber,\n  isValidState,\n  isValidEvent,\n  isEventSupported,\n  isValidClassList,\n} from \"./validate\";\nimport { preventEvent, keyPress } from \"./eventHandlers\";\n\n/**\n * An accessible navigation element in the DOM.\n */\nclass BaseMenu {\n  /**\n   * {@inheritdoc}\n   *\n   * @param {object}               param0                               - The menu object.\n   * @param {HTMLElement}          param0.menuElement                   - The menu element in the DOM.\n   * @param {string}               [param0.menuItemSelector = \"li\"]     - The CSS selector string for menu items.\n   * @param {string}               [param0.menuLinkSelector = \"a\"]      - The CSS selector string for menu links.\n   * @param {string}               [param0.submenuItemSelector = \"\"]    - The CSS selector string for menu items containing submenus.\n   * @param {string}               [param0.submenuToggleSelector = \"a\"] - The CSS selector string for submenu toggle buttons/links.\n   * @param {string}               [param0.submenuSelector = \"ul\"]      - The CSS selector string for submenus.\n   * @param {HTMLElement|null}     [param0.controllerElement = null]    - The element controlling the menu in the DOM.\n   * @param {HTMLElement|null}     [param0.containerElement = null]     - The element containing the menu in the DOM.\n   * @param {string|string[]|null} [param0.openClass = \"show\"]          - The class to apply when a menu is \"open\".\n   * @param {string|string[]|null} [param0.closeClass = \"hide\"]         - The class to apply when a menu is \"closed\".\n   * @param {boolean}              [param0.isTopLevel = false]          - A flag to mark the root menu.\n   * @param {BaseMenu|null}        [param0.parentMenu = null]           - The parent menu to this menu.\n   * @param {boolean}              [param0.isHoverable = false]         - A flag to allow hover events on the menu.\n   * @param {number}               [param0.hoverDelay = 250]            - The delay for closing menus if the menu is hoverable (in miliseconds).\n   */\n  constructor({\n    menuElement,\n    menuItemSelector = \"li\",\n    menuLinkSelector = \"a\",\n    submenuItemSelector = \"\",\n    submenuToggleSelector = \"a\",\n    submenuSelector = \"ul\",\n    controllerElement = null,\n    containerElement = null,\n    openClass = \"show\",\n    closeClass = \"hide\",\n    isTopLevel = true,\n    parentMenu = null,\n    isHoverable = false,\n    hoverDelay = 250,\n  }) {\n    // Run validations.\n    isBoolean({ isTopLevel });\n\n    if (submenuItemSelector !== \"\") {\n      isCSSSelector({\n        menuItemSelector,\n        menuLinkSelector,\n        submenuItemSelector,\n        submenuToggleSelector,\n        submenuSelector,\n      });\n    } else {\n      isCSSSelector({ menuItemSelector, menuLinkSelector });\n    }\n\n    if (controllerElement !== null || containerElement !== null) {\n      isHTMLElement({ menuElement, controllerElement, containerElement });\n    } else {\n      isHTMLElement({ menuElement });\n    }\n\n    if (parentMenu !== null) isMenu({ parentMenu });\n\n    this.domElements = {\n      menu: menuElement,\n      menuItems: [],\n      submenuItems: [],\n      submenuToggles: [],\n      submenus: [],\n      controller: controllerElement,\n      container: containerElement,\n    };\n    this.domSelectors = {\n      menuItems: menuItemSelector,\n      menuLinks: menuLinkSelector,\n      submenuItems: submenuItemSelector,\n      submenuToggles: submenuToggleSelector,\n      submenus: submenuSelector,\n    };\n    this.menuElements = {\n      menuItems: [],\n      submenuToggles: [],\n      controller: null,\n      parentMenu,\n      rootMenu: isTopLevel ? this : null,\n    };\n    this.openClass = openClass || \"\";\n    this.closeClass = closeClass || \"\";\n    this.root = isTopLevel;\n    this.currentChild = 0;\n    this.focusState = \"none\";\n    this.currentEvent = \"none\";\n    this.isHoverable = isHoverable;\n    this.hoverDelay = hoverDelay;\n\n    this.initialize();\n  }\n\n  /**\n   * Initializes the menu.\n   *\n   * This will also initialize all menu items and sub menus.\n   */\n  initialize() {\n    // Get the root menu if it doesn't exist.\n    if (this.elements.rootMenu === null) this.findRootMenu(this);\n\n    // Set all of the DOM elements.\n    this.setDOMElements();\n\n    if (this.isTopLevel) {\n      if (this.dom.controller && this.dom.container) {\n        // Create a new MenuToggle to control the menu.\n        const toggle = new MenuToggle({\n          menuToggleElement: this.dom.controller,\n          parentElement: this.dom.container,\n          controlledMenu: this,\n          openClass: this.openClass,\n          closeClass: this.closeClass,\n        });\n\n        this.menuElements.controller = toggle;\n      }\n    }\n  }\n\n  /**\n   * The DOM elements within the menu.\n   *\n   * @returns {object} - The DOM elements.\n   */\n  get dom() {\n    return this.domElements;\n  }\n\n  /**\n   * The CSS selectors available to the menu.\n   *\n   * @returns {object} - The selectors.\n   */\n  get selectors() {\n    return this.domSelectors;\n  }\n\n  /**\n   * The elements within the menu.\n   *\n   * @returns {object} - The elements.\n   */\n  get elements() {\n    return this.menuElements;\n  }\n\n  /**\n   * The class to apply when the menu is \"open\".\n   *\n   * @returns {string} - The class.\n   */\n  get openClass() {\n    return this.submenuOpenClass;\n  }\n\n  /**\n   * The class to apply when the menu is \"closed\".\n   *\n   * @returns {string} - The class.\n   */\n  get closeClass() {\n    return this.submenuCloseClass;\n  }\n\n  /**\n   * A flag marking the root menu.\n   *\n   * @returns {boolean} - The top-level flag.\n   */\n  get isTopLevel() {\n    return this.root;\n  }\n\n  /**\n   * The index of the currently selected menu item in the menu.\n   *\n   * @returns {number} - The index.\n   */\n  get currentChild() {\n    return this.focussedChild;\n  }\n\n  /**\n   * The current state of the menu's focus.\n   *\n   * @returns {string} - The state.\n   */\n  get focusState() {\n    return this.state;\n  }\n\n  /**\n   * This last event triggered on the menu.\n   *\n   * @returns {string} - The event type.\n   */\n  get currentEvent() {\n    return this.event;\n  }\n\n  /**\n   * The currently selected menu item.\n   *\n   * @returns {MenuItem} - The menu item.\n   */\n  get currentMenuItem() {\n    return this.elements.menuItems[this.currentChild];\n  }\n\n  /**\n   * A flag to allow hover events on the menu.\n   *\n   * @returns {boolean} - The hoverable flag.\n   */\n  get isHoverable() {\n    return this.hoverable;\n  }\n\n  /**\n   * The delay time (in miliseconds) used for mouseout events to take place.\n   *\n   * @returns {number} - The delay time.\n   */\n  get hoverDelay() {\n    return this.delay;\n  }\n\n  /**\n   * Set the class to apply when the menu is \"open\".\n   *\n   * @param {string} value - The class.\n   */\n  set openClass(value) {\n    isValidClassList({ openClass: value });\n\n    this.submenuOpenClass = value;\n  }\n\n  /**\n   * Set the class to apply when the menu is \"closed\".\n   *\n   * @param {string} value - The class.\n   */\n  set closeClass(value) {\n    isValidClassList({ closeClass: value });\n\n    this.submenuCloseClass = value;\n  }\n\n  /**\n   * Set the index currently selected menu item in the menu.\n   *\n   * @param {number} value - The index.\n   */\n  set currentChild(value) {\n    isNumber({ value });\n\n    this.focussedChild = value;\n  }\n\n  /**\n   * Set the state of the menu's focus.\n   *\n   * @param {string} value - The state.\n   */\n  set focusState(value) {\n    isValidState({ value });\n\n    this.state = value;\n  }\n\n  /**\n   * Set the last event triggered on the menu.\n   *\n   * @param {string} value - The event type.\n   */\n  set currentEvent(value) {\n    isValidEvent({ value });\n\n    this.event = value;\n  }\n\n  /**\n   * Set the flag to allow hover events on the menu.\n   *\n   * @param {boolean} value - The hoverable flag.\n   */\n  set isHoverable(value) {\n    isBoolean({ value });\n\n    this.hoverable = value;\n  }\n\n  /**\n   * Set the delay time (in miliseconds) used for mouseout events to take place.\n   *\n   * @param {number} value - The delay time.\n   */\n  set hoverDelay(value) {\n    isNumber({ value });\n\n    this.delay = value;\n  }\n\n  /**\n   * Sets DOM elements within the menu.\n   *\n   * @param {string}      elementType - The type of element to populate.\n   * @param {HTMLElement} base        - The element used as the base for the querySelect.\n   * @param {Function}    filter      - A filter to use to narrow down the DOM elements selected.\n   */\n  setDOMElementType(elementType, base, filter) {\n    if (typeof this.selectors[elementType] === \"string\") {\n      if (base) isHTMLElement({ base });\n\n      const baseElement = base || this.dom.menu;\n      const baseFilter = (item) => item.parentElement === baseElement;\n      const selector = this.selectors[elementType];\n      const domElements = Array.from(baseElement.querySelectorAll(selector));\n\n      if (typeof filter !== \"undefined\") {\n        if (typeof filter === \"function\") {\n          this.domElements[elementType] = domElements.filter((item) =>\n            filter(item)\n          );\n        } else {\n          this.domElements[elementType] = domElements;\n        }\n      } else {\n        this.domElements[elementType] = domElements.filter((item) =>\n          baseFilter(item)\n        );\n      }\n    } else {\n      throw new Error(\n        `${elementType} is not a valid element type within the menu.`\n      );\n    }\n  }\n\n  /**\n   * Adds an element to DOM elements within the menu.\n   *\n   * @param {string}      elementType - The type of element to populate.\n   * @param {HTMLElement} base        - The element used as the base for the querySelect.\n   * @param {Function}    filter      - A filter to use to narrow down the DOM elements selected.\n   */\n  addDOMElementType(elementType, base, filter) {\n    if (typeof this.selectors[elementType] === \"string\") {\n      if (base) isHTMLElement({ base });\n\n      const baseElement = base || this.dom.menu;\n      const baseFilter = (item) => item.parentElement === baseElement;\n      const selector = this.selectors[elementType];\n      const domElements = Array.from(baseElement.querySelectorAll(selector));\n\n      if (typeof filter !== \"undefined\") {\n        if (typeof filter === \"function\") {\n          this.domElements[elementType] = [\n            ...this.domElements[elementType],\n            ...domElements.filter((item) => filter(item)),\n          ];\n        } else {\n          this.domElements[elementType] = [\n            ...this.domElements[elementType],\n            ...domElements,\n          ];\n        }\n      } else {\n        this.domElements[elementType] = [\n          ...this.domElements[elementType],\n          ...domElements.filter((item) => baseFilter(item)),\n        ];\n      }\n    } else {\n      throw new Error(\n        `${elementType} is not a valid element type within the menu.`\n      );\n    }\n  }\n\n  /**\n   * Clears DOM elements within the menu.\n   *\n   * @param {string} elementType - The type of element to clear.\n   */\n  clearDOMElementType(elementType) {\n    if (elementType === \"menu\") return;\n\n    if (Array.isArray(this.domElements[elementType])) {\n      this.domElements[elementType] = [];\n    } else if (typeof this.domElements[elementType] !== \"undefined\") {\n      this.domElements[elementType] = null;\n    } else {\n      throw new Error(\n        `${elementType} is not a valid element type within the menu.`\n      );\n    }\n  }\n\n  /**\n   * Sets all DOM elements within the menu.\n   */\n  setDOMElements() {\n    this.setDOMElementType(\"menuItems\");\n\n    if (this.selectors.submenuItems !== \"\") {\n      this.setDOMElementType(\"submenuItems\");\n\n      this.clearDOMElementType(\"submenuToggles\");\n      this.clearDOMElementType(\"submenus\");\n\n      this.dom.submenuItems.forEach((item) => {\n        this.addDOMElementType(\"submenuToggles\", item);\n        this.addDOMElementType(\"submenus\", item);\n      });\n    }\n  }\n\n  /**\n   * Finds the root menu element.\n   *\n   * @param {BaseMenu} menu - The menu to check.\n   */\n  findRootMenu(menu) {\n    if (menu.isTopLevel) {\n      this.menuElements.rootMenu = menu;\n    } else if (menu.elements.parentMenu !== null) {\n      this.findRootMenu(menu.elements.parentMenu);\n    } else {\n      throw new Error(\"Cannot find root menu.\");\n    }\n  }\n\n  /**\n   * Creates and initializes all menu items and submenus.\n   *\n   * @param {object} MenuType - The menu type for created submenus.\n   */\n  createChildElements(MenuType = BaseMenu) {\n    this.dom.menuItems.forEach((element) => {\n      let menuItem;\n\n      if (this.dom.submenuItems.includes(element)) {\n        // The menu's toggle controller DOM element.\n        const toggler = element.querySelector(this.selectors.submenuToggles);\n        // The actual menu DOM element.\n        const submenu = element.querySelector(this.selectors.submenus);\n\n        // Create the new menu and initialize it.\n        const menu = new MenuType({\n          menuElement: submenu,\n          menuItemSelector: this.selectors.menuItems,\n          menuLinkSelector: this.selectors.menuLinks,\n          submenuItemSelector: this.selectors.submenuItems,\n          submenuToggleSelector: this.selectors.submenuToggles,\n          submenuSelector: this.selectors.submenus,\n          openClass: this.openClass,\n          closeClass: this.closeClass,\n          isTopLevel: false,\n          parentMenu: this,\n          isHoverable: this.isHoverable,\n          hoverDelay: this.hoverDelay,\n        });\n\n        // Create the new MenuToggle.\n        const toggle = new MenuToggle({\n          menuToggleElement: toggler,\n          parentElement: element,\n          controlledMenu: menu,\n          openClass: this.openClass,\n          closeClass: this.closeClass,\n          parentMenu: this,\n        });\n\n        // Add the toggle to the list of toggles.\n        this.menuElements.submenuToggles.push(toggle);\n\n        // Create a new MenuItem.\n        menuItem = new MenuItem({\n          menuItemElement: element,\n          menuLinkElement: toggler,\n          parentMenu: this,\n          isSubmenuItem: true,\n          childMenu: menu,\n          toggle,\n        });\n      } else {\n        const link = element.querySelector(this.selectors.menuLinks);\n\n        // Create a new MenuItem.\n        menuItem = new MenuItem({\n          menuItemElement: element,\n          menuLinkElement: link,\n          parentMenu: this,\n        });\n      }\n\n      this.menuElements.menuItems.push(menuItem);\n    });\n  }\n\n  /**\n   * Handles focus events throughout the menu for proper menu use.\n   */\n  handleFocus() {\n    this.elements.menuItems.forEach((menuItem, index) => {\n      menuItem.dom.link.addEventListener(\"focus\", () => {\n        if (this.elements.parentMenu)\n          this.elements.parentMenu.focusState = \"child\";\n        if (menuItem.elements.childMenu)\n          menuItem.elements.childMenu.focusState = \"none\";\n\n        this.focusState = \"self\";\n        this.currentChild = index;\n      });\n    });\n  }\n\n  /**\n   * Handles click events throughout the menu for proper use.\n   */\n  handleClick() {\n    // Use touch over mouse events when supported.\n    const startEventType = isEventSupported(\"touchstart\", this.dom.menu)\n      ? \"touchstart\"\n      : \"mousedown\";\n    const endEventType = isEventSupported(\"touchend\", this.dom.menu)\n      ? \"touchend\"\n      : \"mouseup\";\n\n    /**\n     * Toggles a toggle element.\n     *\n     * @param {BaseMenu}   menu   - This menu.\n     * @param {MenuToggle} toggle - The menu toggle\n     * @param {Event}      event  - A Javascript event.\n     */\n    function toggleToggle(menu, toggle, event) {\n      preventEvent(event);\n\n      toggle.toggle();\n\n      if (toggle.isOpen) {\n        menu.focusState = \"self\";\n        toggle.elements.controlledMenu.focusState = \"none\";\n      }\n    }\n\n    // Close the menu if a click event happens outside of it.\n    document.addEventListener(endEventType, (event) => {\n      if (this.focusState !== \"none\") {\n        this.currentEvent = \"mouse\";\n\n        if (\n          !this.dom.menu.contains(event.target) &&\n          !this.dom.menu !== event.target\n        ) {\n          this.closeChildren();\n          this.blur();\n\n          if (this.elements.controller) {\n            this.elements.controller.close();\n          }\n        }\n      }\n    });\n\n    this.elements.menuItems.forEach((item, index) => {\n      // Properly focus the current menu item.\n      item.dom.link.addEventListener(startEventType, () => {\n        this.currentEvent = \"mouse\";\n        this.elements.rootMenu.blurChildren();\n        this.focusChild(index);\n      });\n\n      // Properly toggle submenus open and closed.\n      if (item.isSubmenuItem) {\n        item.elements.toggle.dom.toggle[`on${endEventType}`] = (event) => {\n          this.currentEvent = \"mouse\";\n          toggleToggle(this, item.elements.toggle, event);\n        };\n      }\n    });\n\n    // Open the this menu if it's controller is clicked.\n    if (this.isTopLevel && this.elements.controller) {\n      this.elements.controller.dom.toggle[`on${endEventType}`] = (event) => {\n        this.currentEvent = \"mouse\";\n        toggleToggle(this, this.elements.controller, event);\n      };\n    }\n  }\n\n  /**\n   * Handles hover events throughout the menu for proper use.\n   */\n  handleHover() {\n    this.elements.submenuToggles.forEach((toggle) => {\n      toggle.dom.parent.addEventListener(\"mouseenter\", () => {\n        if (this.isHoverable) {\n          this.currentEvent = \"mouse\";\n          toggle.open();\n        }\n      });\n\n      toggle.dom.parent.addEventListener(\"mouseleave\", () => {\n        if (this.isHoverable) {\n          setTimeout(() => {\n            this.currentEvent = \"mouse\";\n            toggle.close();\n          }, this.hoverDelay);\n        }\n      });\n    });\n  }\n\n  /**\n   * Handles keydown events throughout the menu for proper menu use.\n   */\n  handleKeydown() {\n    if (this.isTopLevel && this.elements.controller) {\n      this.elements.controller.dom.toggle.addEventListener(\n        \"keydown\",\n        (event) => {\n          this.currentEvent = \"keyboard\";\n\n          const key = keyPress(event);\n\n          if (key === \"Space\" || key === \"Enter\") {\n            preventEvent(event);\n          }\n        }\n      );\n    }\n  }\n\n  /**\n   * Handles keyup events throughout the menu for proper menu use.\n   */\n  handleKeyup() {\n    if (this.isTopLevel && this.elements.controller) {\n      this.elements.controller.dom.toggle.addEventListener(\"keyup\", (event) => {\n        this.currentEvent = \"keyboard\";\n\n        const key = keyPress(event);\n\n        if (key === \"Space\" || key === \"Enter\") {\n          preventEvent(event);\n          this.elements.controller.open();\n          this.focusFirstChild();\n        }\n      });\n    }\n  }\n\n  /**\n   * Focus the menu.\n   */\n  focus() {\n    this.focusState = \"self\";\n\n    if (this.currentEvent !== \"mouse\") {\n      this.dom.menu.focus();\n    }\n  }\n\n  /**\n   * Unfocus the menu.\n   */\n  blur() {\n    this.focusState = \"none\";\n\n    if (this.currentEvent !== \"mouse\") {\n      this.dom.menu.blur();\n    }\n\n    if (this.isTopLevel && this.elements.controller) {\n      this.elements.controller.close();\n    }\n  }\n\n  /**\n   * Focues the menu's first child.\n   */\n  focusFirstChild() {\n    this.blurCurrentChild();\n    this.currentChild = 0;\n    this.focusCurrentChild();\n  }\n\n  /**\n   * Focus the menu's last child.\n   */\n  focusLastChild() {\n    this.blurCurrentChild();\n    this.currentChild = this.elements.menuItems.length - 1;\n    this.focusCurrentChild();\n  }\n\n  /**\n   * Focus the menu's next child.\n   */\n  focusNextChild() {\n    if (this.currentChild === this.elements.menuItems.length - 1) {\n      this.focusFirstChild();\n    } else {\n      this.blurCurrentChild();\n      this.currentChild = this.currentChild + 1;\n      this.focusCurrentChild();\n    }\n  }\n\n  /**\n   * Focus the menu's last child.\n   */\n  focusPreviousChild() {\n    if (this.currentChild === 0) {\n      this.focusLastChild();\n    } else {\n      this.blurCurrentChild();\n      this.currentChild = this.currentChild - 1;\n      this.focusCurrentChild();\n    }\n  }\n\n  /**\n   * Focus the menu's current child.\n   */\n  focusCurrentChild() {\n    if (this.currentChild !== -1) {\n      this.currentMenuItem.focus();\n    }\n  }\n\n  /**\n   * Blurs the menu's current child.\n   */\n  blurCurrentChild() {\n    if (this.currentChild !== -1) {\n      this.currentMenuItem.blur();\n    }\n  }\n\n  /**\n   * Focus the menu's next child starting with a specific letter.\n   *\n   * @param {string} char - The character to look for.\n   */\n  focusNextChildWithCharacter(char) {\n    // Ensure the character is lowercase just to be safe.\n    const match = char.toLowerCase();\n    let index = this.currentChild + 1;\n    let found = false;\n\n    while (!found && index < this.elements.menuItems.length) {\n      // Ensure the text in the item is lowercase just to be safe.\n      const text =\n        this.elements.menuItems[index].dom.item.innerText.toLowerCase();\n\n      // Focus the child if the text matches, otherwise move on.\n      if (text.startsWith(match)) {\n        found = true;\n        this.currentChild = index;\n        this.focusCurrentChild();\n      }\n\n      index++;\n    }\n  }\n\n  /**\n   * Focus the menu's controller.\n   */\n  focusController() {\n    if (this.dom.controller) {\n      if (this.currentEvent !== \"mouse\") {\n        this.dom.controller.focus();\n      }\n\n      this.focusState = \"none\";\n    }\n  }\n\n  /**\n   * Focus the menu's container.\n   */\n  focusContainer() {\n    if (this.dom.container) {\n      if (this.currentEvent !== \"mouse\") {\n        this.dom.container.focus();\n      }\n\n      this.focusState = \"none\";\n    }\n  }\n\n  /**\n   * Close all submenu children.\n   */\n  closeChildren() {\n    this.elements.submenuToggles.forEach((toggle) => toggle.close());\n  }\n\n  /**\n   * Blurs all children and submenu's children.\n   */\n  blurChildren() {\n    this.elements.menuItems.forEach((menuItem) => {\n      menuItem.blur();\n\n      if (menuItem.isSubmenuItem) {\n        menuItem.elements.childMenu.blurChildren();\n      }\n    });\n  }\n}\n\nexport default BaseMenu;\n","import \"./src/polyfills/array.from.polyfill\";\nimport \"./src/polyfills/array.includes.polyfill\";\nimport \"./src/polyfills/array.find.polyfill\";\nimport \"./src/polyfills/string.startsWith.polyfill\";\nimport \"./src/polyfills/string.endsWith.polyfill\";\nimport \"./src/polyfills/customEvent.polyfill\";\nimport DisclosureMenu from \"./src/disclosureMenu\";\nimport Menubar from \"./src/menubar\";\n\nexport default {\n  DisclosureMenu,\n  Menubar,\n};\n","import BaseMenu from \"./_baseMenu\";\nimport { preventEvent, keyPress } from \"./eventHandlers\";\n\n/**\n * An accessible disclosure menu in the DOM.\n *\n * See https://www.w3.org/TR/wai-aria-practices-1.2/examples/disclosure/disclosure-navigation.html\n */\nclass DisclosureMenu extends BaseMenu {\n  /**\n   * {@inheritdoc}\n   *\n   * @param {object}              param0                               - The menu object.\n   * @param {HTMLElement}         param0.menuElement                   - The menu element in the DOM.\n   * @param {string}              [param0.menuItemSelector = \"li\"]     - The CSS selector string for menu items.\n   * @param {string}              [param0.menuLinkSelector = \"a\"]      - The CSS selector string for menu links.\n   * @param {string}              [param0.submenuItemSelector = \"\"]    - The CSS selector string for menu items containing submenus.\n   * @param {string}              [param0.submenuToggleSelector = \"a\"] - The CSS selector string for submenu toggle buttons/links.\n   * @param {string}              [param0.submenuSelector = \"ul\"]      - The CSS selector string for submenus.\n   * @param {HTMLElement|null}    [param0.controllerElement = null]    - The element controlling the menu in the DOM.\n   * @param {HTMLElement|null}    [param0.containerElement = null]     - The element containing the menu in the DOM.\n   * @param {string}              [param0.openClass = \"show\"]          - The class to apply when a menu is \"open\".\n   * @param {string}              [param0.closeClass = \"hide\"]         - The class to apply when a menu is \"closed\".\n   * @param {boolean}             [param0.isTopLevel = false]          - A flag to mark the root menu.\n   * @param {DisclosureMenu|null} [param0.parentMenu = null]           - The parent menu to this menu.\n   * @param {boolean}             [param0.isHoverable = false]         - A flag to allow hover events on the menu.\n   * @param {number}              [param0.hoverDelay = 250]            - The delay for closing menus if the menu is hoverable (in miliseconds).\n   */\n  constructor({\n    menuElement,\n    menuItemSelector = \"li\",\n    menuLinkSelector = \"a\",\n    submenuItemSelector = \"\",\n    submenuToggleSelector = \"a\",\n    submenuSelector = \"ul\",\n    controllerElement = null,\n    containerElement = null,\n    openClass = \"show\",\n    closeClass = \"hide\",\n    isTopLevel = true,\n    parentMenu = null,\n    isHoverable = false,\n    hoverDelay = 250,\n  }) {\n    super({\n      menuElement,\n      menuItemSelector,\n      menuLinkSelector,\n      submenuItemSelector,\n      submenuToggleSelector,\n      submenuSelector,\n      controllerElement,\n      containerElement,\n      openClass,\n      closeClass,\n      isTopLevel,\n      parentMenu,\n      isHoverable,\n      hoverDelay,\n    });\n\n    this.currentChild = -1;\n  }\n\n  /**\n   * Initializes the menu.\n   *\n   * This will also initialize all menu items and sub menus.\n   */\n  initialize() {\n    super.initialize();\n\n    this.createChildElements(DisclosureMenu);\n    this.handleFocus();\n    this.handleClick();\n    if (this.isHoverable) this.handleHover();\n    this.handleKeydown();\n    this.handleKeyup();\n  }\n\n  /**\n   * Handles keydown events throughout the menu for proper menu use.\n   */\n  handleKeydown() {\n    super.handleKeydown();\n\n    this.dom.menu.addEventListener(\"keydown\", (event) => {\n      this.currentEvent = \"keyboard\";\n\n      const key = keyPress(event);\n\n      // Prevent default event actions if we're handling the keyup event.\n      if (this.focusState === \"self\") {\n        const keys = [\n          \"ArrowUp\",\n          \"ArrowRight\",\n          \"ArrowDown\",\n          \"ArrowLeft\",\n          \"Home\",\n          \"End\",\n        ];\n        const submenuKeys = [\"Space\", \"Enter\"];\n        const controllerKeys = [\"Escape\"];\n        const parentKeys = [\"Escape\"];\n\n        if (keys.includes(key)) {\n          preventEvent(event);\n        } else if (\n          this.currentMenuItem.isSubmenuItem &&\n          submenuKeys.includes(key)\n        ) {\n          preventEvent(event);\n        } else if (this.elements.controller && controllerKeys.includes(key)) {\n          preventEvent(event);\n        } else if (this.elements.parentMenu && parentKeys.includes(key)) {\n          preventEvent(event);\n        }\n      }\n    });\n  }\n\n  /**\n   * Handles keyup events throughout the menu for proper menu use.\n   */\n  handleKeyup() {\n    super.handleKeyup();\n\n    this.dom.menu.addEventListener(\"keyup\", (event) => {\n      this.currentEvent = \"keyboard\";\n\n      const key = keyPress(event);\n\n      if (this.focusState === \"self\") {\n        if (key === \"Space\" || key === \"Enter\") {\n          // Hitting Space or Enter:\n          // - If focus is on a disclosure button, activates the button, which toggles the visibility of the dropdown.\n          // - Click handling of other links in the menu is handled by the browser.\n          if (this.currentMenuItem.isSubmenuItem) {\n            preventEvent(event);\n            this.currentMenuItem.elements.toggle.preview();\n          }\n        } else if (key === \"Escape\") {\n          // Hitting Escape\n          // - If a dropdown is open, closes it.\n          // - If was within the closed dropdown, sets focus on the button that controls that dropdown.\n          const hasOpenChild = this.elements.submenuToggles.some(\n            (toggle) => toggle.isOpen\n          );\n\n          if (hasOpenChild) {\n            preventEvent(event);\n            this.closeChildren();\n          } else if (this.elements.parentMenu) {\n            preventEvent(event);\n            this.elements.parentMenu.closeChildren();\n            this.elements.parentMenu.focusCurrentChild();\n          } else if (\n            this.isTopLevel &&\n            this.elements.controller &&\n            this.elements.controller.isOpen\n          ) {\n            this.elements.controller.close();\n            this.focusController();\n          }\n        } else if (key === \"ArrowDown\" || key === \"ArrowRight\") {\n          // Hitting the Down or Right Arrow:\n          // - If focus is on a button and its dropdown is collapsed, and it is not the last button, moves focus to the next button.\n          // - If focus is on a button and its dropdown is expanded, moves focus to the first link in the dropdown.\n          // - If focus is on a link, and it is not the last link, moves focus to the next link.\n          preventEvent(event);\n\n          if (\n            this.currentMenuItem.isSubmenuItem &&\n            this.currentMenuItem.elements.toggle.isOpen\n          ) {\n            this.currentMenuItem.elements.childMenu.focusFirstChild();\n          } else {\n            this.focusNextChild();\n          }\n        } else if (key === \"ArrowUp\" || key === \"ArrowLeft\") {\n          // Hitting the Up or Left Arrow:\n          // - If focus is on a button, and it is not the first button, moves focus to the previous button.\n          // - If focus is on a link, and it is not the first link, moves focus to the previous link.\n          preventEvent(event);\n          this.focusPreviousChild();\n        } else if (key === \"Home\") {\n          // Hitting Home:\n          // - If focus is on a button, and it is not the first button, moves focus to the first button.\n          // - If focus is on a link, and it is not the first link, moves focus to the first link.\n          preventEvent(event);\n          this.focusFirstChild();\n        } else if (key === \"End\") {\n          // Hitting End:\n          // - If focus is on a button, and it is not the last button, moves focus to the last button.\n          // - If focus is on a link, and it is not the last link, moves focus to the last link.\n          preventEvent(event);\n          this.focusLastChild();\n        }\n      }\n    });\n  }\n\n  /**\n   * Focus the menu's next child.\n   */\n  focusNextChild() {\n    if (this.currentChild < this.elements.menuItems.length - 1) {\n      this.blurCurrentChild();\n      this.currentChild = this.currentChild + 1;\n      this.focusCurrentChild();\n    }\n  }\n\n  /**\n   * Focus the menu's last child.\n   */\n  focusPreviousChild() {\n    if (this.currentChild > 0) {\n      this.blurCurrentChild();\n      this.currentChild = this.currentChild - 1;\n      this.focusCurrentChild();\n    }\n  }\n}\n\nexport default DisclosureMenu;\n"],"names":["toStr","isCallable","maxSafeInteger","toLength","isHTMLElement","element","name","HTMLElement","_typeof","Error","key","error","TypeError","isCSSSelector","value","isString","document","querySelector","isBoolean","isNumber","isMenu","BaseMenu","isEventSupported","event","isValidClassList","Array","isArray","forEach","item","from","Object","prototype","toString","fn","call","Math","pow","len","number","Number","isNaN","isFinite","floor","abs","toInteger","min","max","arrayLike","C","this","items","T","mapFn","arguments","length","kValue","A","k","includes","search","indexOf","find","defineProperty","predicate","o","thisArg","configurable","writable","String","startsWith","rawPos","pos","substring","endsWith","this_len","undefined","window","CustomEvent","params","bubbles","cancelable","detail","evt","createEvent","initCustomEvent","MenuToggle","menuToggleElement","parentElement","controlledMenu","openClass","closeClass","parentMenu","domElements","toggle","parent","menuElements","isOpen","expandEvent","collapseEvent","initialize","dom","setAttribute","tagName","tag","toLowerCase","check","isTag","id","elements","menu","randomString","random","replace","substr","innerText","finalID","getAttribute","slice","classList","add","_this","show","controlledMenuOpenClass","controlledMenuCloseClass","_this2","remove","dispatchEvent","_this3","expand","closeSiblings","focusState","collapse","closeChildren","currentChild","blur","close","open","submenuToggles","_this4","keyPress","KeyboardEvent","isKeyboardEvent","keyCode","keys","Enter","Space","Escape","ArrowUp","ArrowRight","ArrowDown","ArrowLeft","Home","End","Character","match","Tab","preventEvent","Event","isEvent","preventDefault","stopPropagation","Menubar","menuElement","menuItemSelector","menuLinkSelector","submenuItemSelector","submenuToggleSelector","submenuSelector","controllerElement","containerElement","isTopLevel","isHoverable","hoverDelay","createChildElements","handleFocus","handleClick","handleHover","handleKeydown","handleKeyup","menuItems","link","tabIndex","addEventListener","currentEvent","rootMenu","focus","currentMenuItem","isSubmenuItem","controller","altKey","crtlKey","metaKey","requestAnimationFrame","childMenu","focusFirstChild","previousChildOpen","focusNextChild","preview","focusPreviousChild","focusLastChild","some","focusController","focusCurrentChild","focusNextChildWithCharacter","MenuItem","menuItemElement","menuLinkElement","isMenuToggle","isController","isMenubar","submenuItems","submenus","container","domSelectors","menuLinks","root","findRootMenu","setDOMElements","submenuOpenClass","submenuCloseClass","focussedChild","state","validStates","join","isValidState","isValidEvent","hoverable","delay","elementType","base","filter","selectors","baseElement","selector","querySelectorAll","baseFilter","setDOMElementType","clearDOMElementType","addDOMElementType","MenuType","menuItem","toggler","submenu","push","index","startEventType","endEventType","toggleToggle","contains","target","blurChildren","focusChild","_this5","setTimeout","_this6","_this7","blurCurrentChild","char","found","DisclosureMenu"],"mappings":"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"}